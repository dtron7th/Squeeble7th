<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eden Economy</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&family=Cantarell:ital,wght@0,400;0,700;1,400;1,700&family=Cascadia+Code:ital,wght@0,200..700;1,200..700&family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Hind+Siliguri:wght@300;400;500;600;700&family=Inconsolata:wdth,wght@105.8,200..900&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=Quicksand:wght@300..700&family=Rajdhani:wght@300;400;500;600;700&family=Sometype+Mono:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
    

    <style>
      * {
            padding: 0px;
            margin: 0px;
            font-family: "Sometype Mono", monospace;
            font-weight: 100;  
        }

        @font-face {
            font-family: DOS;
            src: url(/Fonts/DOS/Px437_ACM_VGA_8x14.ttf)
        }

        *::-webkit-scrollbar {
            display: none;
        }

        :root {
            --Main_Text: 10px;
            --Main_Text_1: 13px;
            --Main_Text_Color: rgb(255, 255, 255);
            --Main_Window_Color-1: rgba(0, 0, 0, 0.05);
            --Main_Window_Color-2: rgba(0, 0, 0, 0.212);
            --Main_Window_Header_Color-1: rgb(47, 67, 80);
            --Login_Window_Color-1: rgb(0, 0, 0);
            --Login_Window_Color-2: rgb(255, 255, 255);
            --Dropdown_Window_Color: rgba(0, 0, 0, 0.1);
            --Main_Border: rgba(255, 255, 255, 0.2);
            --Text_Input_Field: rgba(0, 0, 0, 0.25);
            --Text_Input_Field-Actove: rgba(16, 137, 146, 0.3);

            --Menu_Background: rgba(0, 0, 0, 0.3);
            --Box_Shadow: 10px 10px 10px rgba(0, 0, 0, 0.5);
            --Back_drop: blur(20px);

            --Profile_Pic_Background: rgba(0, 0, 0, 0.3);
            --Active_Border: rgba(0, 255, 170, 0.5);
        }

    </style>

    <!-- Index -->
    <style>
        body {
            background-color: rgb(255, 255, 255);
            overflow: hidden;
            width: 100dvw;
            height: 100dvh;
            display: flex;
            justify-content: center;
        }

        /* Wallpaper for login screen*/

        .Wallpaper {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
            background-size: contain;
        }

        .Wallpaper > .Img_List {
            display: flex;
        }

        .Wallpaper > .Img_List > img {
            width: 100dvw;
            height: 100dvh;
            background-size: cover;
        }

        /* UI system */

        

        .Window {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--Main_Window_Color-1);
            backdrop-filter: var(--Back_drop);
            overflow: hidden;
            border: 1px solid var(--Main_Border);
            box-shadow: var(--Box_Shadow);
            display: flex;
            flex-direction: column;
        }

        .Window > .Window_Header {
            position: absolute;
            top: 0px;
            width: 100%;
            height: 30px;
            background-color: var(--Main_Window_Header_Color-1);
            display: flex;
            align-items: center;
        }

        .Window > .Window_Header > .Title {
            margin-left: 10px;
            color: var(--Main_Text_Color);
            font-size: var(--Main_Text);
        }

        .Window > .Window_Header > .Max_Size_Button {
            position: absolute;
            right: 30px;
            width: 10px;
            height: 10px;
            background-color: rgb(0, 255, 115);
            border: none;
            outline: none;
            border-radius: 50%;
        }

        .Window > .Window_Header > .Close_Button {
            position: absolute;
            right: 10px;
            width: 10px;
            height: 10px;
            background-color: rgb(255, 0, 0);
            border: none;
            outline: none;
            border-radius: 50%;
        }

        .Window > .Content {
            position: absolute;
            top: 30px;
            width: 100%;
            height: calc( 100% - 30px);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        input {
            border: none;
            outline: none;
            background-color: var(--Text_Input_Field);
            text-indent: 10px;
            color: var(--Main_Text_Color);
            font-size: var(--Main_Text);
        }

        input::placeholder {
            text-indent: 10px;
            color: var(--Main_Text_Color);
            font-size: var(--Main_Text);
        }

        

        button {
            border: none;
            outline: none;
            background-color: var(--Text_Input_Field);
            color: var(--Main_Text_Color);
            font-size: var(--Main_Text);
            cursor: pointer;
        }

        button:active {
            background-color: var(--Text_Input_Field-Active);
        }

        .Floating_Button {
            position: absolute;
            display: flex;
            justify-content: center;
            backdrop-filter: blur(20px);
            font-size: var(--Main_Text);
            border: 1px solid var(--Main_Border);
            outline: none;
            box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }

        .Dropdown_Window {
            position: absolute;
            background-color: var(--Text_Input_Field);
            box-shadow: var(--Box_Shadow);
            backdrop-filter: var(--Back_drop);
        }

        .Dropdown_Window > .Dropdown_Window_Button {
            text-align: left;
            text-indent: 10px;
        }

        .Fullscreen_Dialog {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 100vw;
            height: 100vh;
            background-color: var(--Menu_Background);
            backdrop-filter: var(--Back_drop);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }

        /* Main */
        
        .Disclaimer {
            position: absolute;
            width: 100%;
            height: 100%;
            backdrop-filter: var(--Back_drop);
            background-color: var(--Main_Window_Color-2);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        .Disclaimer > .Disclaimer_Window {
            position: absolute;
            width: 300px;
            height: 200px;
            background-color: var(--Main_Window_Color-2);
            border: 1px solid var(--Main_Border);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .On_Button {
            position: absolute;
            width: auto;
            height: auto;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .On_Button > button {
            position: absolute;
            width: auto;
            height: auto;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: var(--Back_drop);
        }

        .On_Button > button > img {
            height: 20px;
        }

        .Progress_Bar {
            position: absolute;
            bottom: 10px;
            width: calc(100% - 20px);
            height: 30px;
            background-color: var(--Text_Input_Field);
            backdrop-filter: blur(20px);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .Progress_Fill {
            position: absolute;
            left: 0px;
            height: 30px;
            width: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: width 0.3s ease-in-out;
        }

        .Progress_Label {
            position: absolute;
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
        }

        .Login {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            display: none;
        }

        .Login > .Login_Window > .Content > .Main {
            position: absolute;
            top: 100px;
            width: calc(100% - 40px);
            display: flex;
            justify-content: center;
            flex-direction: column;
        }

        .Login > .Login_Window > .Content > .Main  > .Inputs {
            display: flex;
            justify-content: center;
            flex-direction: column;
            gap: 10px;
        }

        .Login > .Login_Window > .Content > .Main  > .Inputs > .Field {
            width: 100%;
            height: 30px;
            background-color: var(--Text_Input_Field);
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
            gap: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-indent: 10px;
            overflow: hidden;
        }

        .Login > .Login_Window > .Content > .Main  > .Inputs > .Login_SHA-256_Output {
            width: 100%;
            height: 30px;
            background-color: var(--Text_Input_Field);
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
            gap: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-indent: 10px;
            overflow: hidden;
        }

        .Login > .Login_Window > .Content > .Main > .Buttons {
            position: absolute;
            top: 90px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Login > .Login_Window > .Content > .Manual {
            position: absolute;
            bottom: 20px;
            width: calc(100% - 40px);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .Login > .Login_Window > .Content > .Manual > .Hash_Name {
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Login > .Login_Window > .Content > p {
            width: calc(100% - 40px);
        }

        .Signup_Window {
            position: relative;
            display: none;
            overflow: hidden;
            overflow-y: scroll;
        }

        .Signup_Window > .Window_Header {
            position: sticky;
            z-index: 1;
        }

        .Signup_Window > .Content {
            position: relative;
            display: flex;
            justify-content: center;
            align-self: center;
        }

        .Signup_Window > .Content > .Main_Title {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        .Signup_Window > .Content > .Main_Title > p {
            font-size: 16px;
            color: var(--Main_Text_Color);
        }

        .Signup_Window > .Content > .Signup_Profile {
            position: absolute;
            top: 20px;
            right: 20px;
            width: calc(100% - 120px);
        }

        .Signup_Window > .Content > .Signup_Profile > .Signup_Profile_Bubble {
            position: absolute;
            right: 0px;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            overflow: hidden;
        }

        .Signup_Window > .Content > .Signup_Profile > .Signup_Profile_Bubble > img {
            width: 70px;
            height: 70px;
            background-color: var(--Profile_Pic_Background);
        }

        .Signup_Window > .Content > .Signup_Profile > .Signup_Profile_Name {
            position: absolute;
            top: 0px;
            right: 80px;
            width: 50%;
            font-size: 16px;
            color: var(--Main_Text_Color);
            text-align: right;
        }
    
        .Signup_Window > .Content > .Signup_Profile > .Signup_Profile_Name > p {
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
        }

        .Signup_Window > .Content > .Signup_Wallpaper {
            position: absolute;
            top: 110px;
            width: calc(100% - 40px);
            height: 130px;
        }

        .Signup_Window > .Content > .Signup_Wallpaper > .Signup_Wallpaper_Container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .Signup_Window > .Content > .Signup_Wallpaper > .Signup_Wallpaper_Container > img {
            width: 100%;
            background-size: contain;
        }

        .Signup_Window > .Content > .Signup_Wallpaper > .Get_Signup_Wallpaper {
            margin-top: 10px;
        }

        .Signup_Window > .Content > .Inputs {
            width: calc(100% - 40px);
            overflow-y: scroll;
        }

        .Signup_Window > .Content > .Inputs > .First_Basic_Inputs {
            position: absolute;
            top: 310px;
            width: calc(100% - 40px);
        }

        .Signup_Window > .Content > .Inputs > .First_Basic_Inputs > .Hash_Output {
            position: absolute;
            top: 50px;
            width: 100%;
        }

        .Signup_Window > .Content > .Inputs > .First_Basic_Inputs > .Hash_Output > .Signup_SHA-256_Output {
            width: 100%;
            height: 30px;
            background-color: var(--Text_Input_Field);
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
            gap: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-indent: 10px;
            overflow: hidden;
        }

        .Signup_Window > .Content > .Inputs > .First_Basic_Inputs > .Name {
            position: absolute;
            top: 100px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Signup_Window > .Content > .Inputs > .First_Basic_Inputs > .Signup_Password {
            position: absolute;
            top: 140px;
            width: 100%;
        }

        .Signup_Window > .Content > .Inputs > .Second_Basic_Inputs {
            position: absolute;
            top: 510px;
            width: calc(100% - 40px);
        }

        .Signup_Window > .Content > .Inputs > .Second_Basic_Inputs > .Hash_Output {
            position: absolute;
            top: 50px;
            width: 100%;
        }

        .Signup_Window > .Content > .Inputs > .Second_Basic_Inputs > .Hash_Output > .Signup_SHA-256_Output {
            width: 100%;
            height: 30px;
            background-color: var(--Text_Input_Field);
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
            gap: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-indent: 10px;
            overflow: hidden;
        }

        .Signup_Window > .Content > .Inputs > .Second_Basic_Inputs > .Name {
            position: absolute;
            top: 100px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Signup_Window > .Content > .Inputs > .Second_Basic_Inputs > .Information_1 {
            position: absolute;
            top: 140px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Signup_Window > .Content > .Inputs > .Second_Basic_Inputs > .Information_2 {
            position: absolute;
            top: 180px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
            padding-bottom: 20px;
        }

        .Login > .Close_Login_Menu {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--Menu_Background);
            backdrop-filter: var(--Back_drop);
            display: flex;
            justify-content: center;
            align-items: center;
            display: none;
        }

        .Login > .Close_Login_Menu > .Menu_Container {
            position: absolute;
            width: 200px;
            height: auto;
            background-color: var(--Main_Window_Color-2);
        }

        .Login > .Verification_Window {
            display: none;
        }

        .Login > .Verification_Window > .Content {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .Login > .Verification_Window > .Content > .Verification_Window_Profile {
            position: absolute;
            top: 30px;
            width: 70px;
            height: 70px;
            overflow: hidden;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .Login > .Verification_Window > .Content > .Verification_Window_Profile > img {
            width: 100%;
            background-size: contain;
        }

        .Login > .Verification_Window > .Content > .Data {
            position: absolute;
            bottom: 80px;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .Login > .Verification_Window > .Content > .Data > span {
            width: 150px;
            text-align: center;
            font-size: var(--Main_Text_1);
            color: var(--Main_Text_Color);
        }

        .Login > .Verification_Window > .Content > .Buttons {
            width: 100%;
            position: absolute;
            bottom: 20px;
            display: flex;
            justify-content: center;
        }

        /* Dropdown Styles */

        .Signup_Profile_Options_Dropdown  {
            width: 150px;
            height: auto;
        }

        .Signup_Upload_Profile_Dialog > .Content {
            display: flex;
            justify-content: center;
        }

        .Signup_Upload_Profile_Dialog {
            display: none;
        }

        .Signup_Upload_Profile_Dialog > .Content > .Signup_Upload_Profile_Dialog_Profile_Pic {
            position: absolute;
            top: 20px;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            overflow: hidden;
        }

        .Signup_Upload_Profile_Dialog > .Content > .Signup_Upload_Profile_Dialog_Profile_Pic > img {
            width: 70px;
            height: 70px;
            background-color: var(--Profile_Pic_Background);
        }

        .Signup_Upload_Profile_Dialog > .Content > .Buttons {
            position: absolute;
            bottom: 10px;
            width: calc(100% - 20px);
            display: flex;
            gap: 10px;
        }

        .Forgot_Password_Dialog {
            display: none;
        }

        .Forgot_Password_Dialog > .Content > .Description {
            position: absolute;
            top: 30px;
            width: calc(100% - 40px);
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
        }

        .Forgot_Password_Dialog > .Content > .Forgotpassword_Output_Hash {
            position: absolute;
            top: 80px;
            width: calc(100% - 40px);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .Forgot_Password_Dialog > .Content > .Forgotpassword_Output_Hash > .Forgotpassword_SHA-256_Output {
            width: 100%;
            height: 30px;
            background-color: var(--Text_Input_Field);
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
            gap: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-indent: 10px;
            overflow: hidden;
        }

        .Forgot_Password_Dialog > .Content > .Forgotpassword_Inputs {
            position: absolute;
            top: 180px;
            width: calc(100% - 40px);
            
        }

        .Forgot_Password_Dialog > .Content > .Forgotpassword_Inputs > .Name {
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
            
        }

        .Forgot_Password_Dialog > .Content > .Forgotpassword_Inputs > .Information_1 {
            margin-top: 10px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Forgot_Password_Dialog > .Content > .Forgotpassword_Inputs > .Information_2 {
            margin-top: 10px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .Forgot_Password_Show_Password_Dialog {
            display: flex;
            justify-content: center;
            align-items: center;
            display: none;
        }

        .Forgot_Password_Show_Password_Dialog > .Fields {
            position: absolute;
            top: 400px;
            display: flex;
            justify-content: center;
            text-align: center;
            flex-direction: column;
            gap: 20px; 
            font-size: var(--Main_Text);
            color: var(--Main_Text_Color);
        }

        .Forgot_Password_Show_Password_Dialog > .Fields > .Recovered_Password {
            font-size: 14px;
        }

        .Forgot_Password_Show_Password_Dialog > .Close_Button {
            position: absolute;
            top: 480px;
        }
    </style>
</head>

    <!-- This is where you can add to the app -->

<body id="Main_Body">
    <div class="Wallpaper">
        <div class="Img_List">
            <img src="/Images/Background Img/Login_wallpaper-1.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-2.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-3.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-4.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-5.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-6.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-7.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-8.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-9.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-10.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-11.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-12.jpg" alt="">
            <img src="/Images/Background Img/Login_wallpaper-13.jpg" alt="">
            
        </div>
    </div>

    <div class="Keyboard">
        <!-- Virtual Keyboard -->
        <style>
            .VirtualKeyboard {
            position: fixed;
            left: 10px;
            right: 10px;
            bottom: 10px;
            background: var(--Main_Window_Color-1);
            border: 1px solid var(--Main_Border);
            backdrop-filter: blur(20px);
            padding: 8px;
            z-index: 9999;
            box-shadow: var(--Box_Shadow);
            user-select: none;
            -webkit-user-select: none;
            display: none;
            }

            .vk-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            justify-content: center;
            }

            .vk-key {
            flex: 1 0 0;
            min-width: 28px;
            padding: 10px 6px;
            text-align: center;
            background: var(--Text_Input_Field);
            color: var(--Main_Text_Color);
            font-size: calc(var(--Main_Text));
            outline: none;
            box-shadow: inset 0 -2px rgba(0,0,0,0.15);
            touch-action: manipulation;
            -webkit-appearance: none;
            appearance: none;
            }

            .vk-key.wide { flex: 2.4; min-width: 60px; }
            .vk-key.extra { flex: 1.6; min-width: 48px; }
            .vk-key:active { transform: translateY(1px); background: var(--Text_Input_Field-Actove); box-shadow: inset 0 -2px rgba(0,0,0,0.15), inset 0 0 0 1px var(--Active_Border); }
            .vk-key.active { transform: translateY(1px) !important; background: var(--Text_Input_Field-Actove) !important; box-shadow: inset 0 -2px rgba(0,0,0,0.15), inset 0 0 0 1px var(--Active_Border) !important; }
            .vk-hidden { display: none !important; }

            /* show caret for the tracked inputs (even when inputmode/readonly is used) */
            input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field {
            caret-color: var(--Main_Text_Color);
            -webkit-text-fill-color: var(--Main_Text_Color);
            user-select: text; /* allow selection so caret is visible */
            }

            /* make focus state clearly visible and encourage caret rendering */
            input.Field:focus, #Printed_Text:focus, #Hash_Name:focus, #Password:focus, textarea.Field:focus {
            outline: none;
            border: 1px solid var(--Active_Border);
            }

            /* visible focus for keyboard users */
            input.Field:focus-visible, #Printed_Text:focus-visible, #Hash_Name:focus-visible, #Password:focus-visible, textarea.Field:focus-visible {
            border: 1px solid var(--Active_Border);
            }

            /* fallback: some browsers hide the native caret for readonly inputs.
               Provide a simple blinking faux-caret using an absolutely positioned element
               inside the Keyboard container when a tracked input is focused.
               The script sets .vk-shows-caret on the body to toggle this. */
            .vk-faux-caret {
            position: absolute;
            width: 1px;
            background: var(--Main_Text_Color);
            animation: vk-caret-blink 1s steps(1) infinite;
            pointer-events: none;
            height: 1em;
            transform: translateY(-0.15em);
            }

            @keyframes vk-caret-blink {
            0%   { opacity: 1; }
            50%  { opacity: 0; }
            100% { opacity: 1; }
            }
        </style>

        <div class="VirtualKeyboard" id="VirtualKeyboard" aria-hidden="false" role="application">
            <div class="vk-row" id="vk-row-1">
                <button class="vk-key" data-key="q">q</button>
                <button class="vk-key" data-key="w">w</button>
                <button class="vk-key" data-key="e">e</button>
                <button class="vk-key" data-key="r">r</button>
                <button class="vk-key" data-key="t">t</button>
                <button class="vk-key" data-key="y">y</button>
                <button class="vk-key" data-key="u">u</button>
                <button class="vk-key" data-key="i">i</button>
                <button class="vk-key" data-key="o">o</button>
                <button class="vk-key" data-key="p">p</button>
            </div>

            <div class="vk-row" id="vk-row-2">
                <button class="vk-key" data-key="a">a</button>
                <button class="vk-key" data-key="s">s</button>
                <button class="vk-key" data-key="d">d</button>
                <button class="vk-key" data-key="f">f</button>
                <button class="vk-key" data-key="g">g</button>
                <button class="vk-key" data-key="h">h</button>
                <button class="vk-key" data-key="j">j</button>
                <button class="vk-key" data-key="k">k</button>
                <button class="vk-key" data-key="l">l</button>
            </div>

            <div class="vk-row" id="vk-row-3">
                <button class="vk-key extra" data-action="shift" id="vk-shift">Shift</button>
                <button class="vk-key" data-key="z">z</button>
                <button class="vk-key" data-key="x">x</button>
                <button class="vk-key" data-key="c">c</button>
                <button class="vk-key" data-key="v">v</button>
                <button class="vk-key" data-key="b">b</button>
                <button class="vk-key" data-key="n">n</button>
                <button class="vk-key" data-key="m">m</button>
                <button class="vk-key extra" data-action="backspace">⌫</button>
            </div>

            <div class="vk-row" id="vk-row-4">
                <button class="vk-key wide" data-action="numbers" id="vk-numbers">123</button>
                <button class="vk-key" data-key=",">,</button>
                <button class="vk-key" data-key=".">.</button>
                <button class="vk-key wide" data-action="space">Space</button>
                <button class="vk-key" data-action="enter">⏎</button>
                <button class="vk-key" data-action="hide" id="vk-hide">Hide</button>
            </div>
        </div>

        <audio id="vk-sound" preload="auto">
            <source src="/Sounds/Scifi/ui-sounds-pack-3-11-359714.mp3" type="audio/mpeg">
        </audio>

        <script>
        (function(){
            const keyboard = document.getElementById('VirtualKeyboard');
            const keys = keyboard.querySelectorAll('.vk-key');
            let shift = false;
            let numbersMode = false;
            let activeInput = null;

            // target inputs we care about
            const inputSelector = 'input.Field, #Printed_Text, #Hash_Name, #Password';
            const inputs = Array.from(document.querySelectorAll(inputSelector));

            // Ensure each key keeps its original base character so we can switch back reliably
            keyboard.querySelectorAll('.vk-key[data-key]').forEach(btn => {
                const k = btn.getAttribute('data-key') || '';
                if (!btn.dataset.base) btn.dataset.base = k.toLowerCase();
            });

            // show keyboard when a tracked input receives focus
            document.addEventListener('focusin', (e) => {
                if (e.target && e.target.matches && e.target.matches(inputSelector)) {
                    activeInput = e.target;
                    keyboard.style.display = 'block';
                    keyboard.setAttribute('aria-hidden','false');
                }
            });

            // keep activeInput when tapping keyboard (prevent blur)
            keyboard.addEventListener('touchstart', (ev) => {
                ev.preventDefault(); // prevent mobile from blurring inputs
            }, { passive: false });

            // helper to dispatch input events
            function dispatchInput(el) {
                try {
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                } catch(e){}
            }

            function insertAtCursor(el, text) {
                if (!el) return;
                if (typeof el.selectionStart === 'number') {
                    const start = el.selectionStart;
                    const end = el.selectionEnd;
                    const value = el.value || '';
                    el.value = value.slice(0, start) + text + value.slice(end);
                    const pos = start + text.length;
                    el.selectionStart = el.selectionEnd = pos;
                    dispatchInput(el);
                } else {
                    el.value = (el.value || '') + text;
                    dispatchInput(el);
                }
                // keep focus on input
                try { el.focus(); } catch(e){}
            }

            function performBackspace(el) {
                if (!el) return;
                if (typeof el.selectionStart === 'number') {
                    const start = el.selectionStart;
                    const end = el.selectionEnd;
                    if (start === end && start > 0) {
                        const value = el.value || '';
                        el.value = value.slice(0, start - 1) + value.slice(end);
                        el.selectionStart = el.selectionEnd = start - 1;
                    } else if (start !== end) {
                        const value = el.value || '';
                        el.value = value.slice(0, start) + value.slice(end);
                        el.selectionStart = el.selectionEnd = start;
                    }
                    dispatchInput(el);
                } else {
                    el.value = (el.value || '').slice(0, -1);
                    dispatchInput(el);
                }
                try { el.focus(); } catch(e){}
            }

            function toggleShift() {
                shift = !shift;
                updateKeys();
                document.getElementById('vk-shift').style.background = shift ? 'rgba(255,255,255,0.06)' : '';
            }

            function toggleNumbers() {
                numbersMode = !numbersMode;
                // reset shift when entering numbers for consistent UX
                if (numbersMode) shift = false;
                updateKeys();
                document.getElementById('vk-numbers').textContent = numbersMode ? 'ABC' : '123';
            }

            function updateKeys() {
                const letterButtons = keyboard.querySelectorAll('.vk-key[data-key]');
                letterButtons.forEach(btn => {
                    const base = (btn.dataset.base || btn.getAttribute('data-key') || '').toLowerCase();
                    if (!base) return;

                    if (!numbersMode) {
                        // restore alphabetic layout from base and apply shift
                        const display = shift ? base.toUpperCase() : base.toLowerCase();
                        btn.textContent = display;
                        btn.setAttribute('data-key', display);
                    } else {
                        // numbers/symbols layout mapped from base (base remains unchanged)
                        const map = {
                            'q':'1','w':'2','e':'3','r':'4','t':'5','y':'6','u':'7','i':'8','o':'9','p':'0',
                            'a':'@','s':'_','d':'-','f':'/','g':':','h':';','j':'(', 'k':')','l':'$',
                            'z':'&','x':'*','c':'"','v':'\'','b':'%','n':'+','m':'='
                        };
                        const out = map[base] || base;
                        btn.textContent = out;
                        btn.setAttribute('data-key', out);
                    }
                });
            }

            // initial state
            updateKeys();

            keyboard.addEventListener('click', (e) => {
                const btn = e.target.closest('.vk-key');
                if (!btn) return;
                const action = btn.getAttribute('data-action');
                const key = btn.getAttribute('data-key');

                // find active input or fallback to Printed_Text
                if (!activeInput || !document.body.contains(activeInput)) {
                    activeInput = document.getElementById('Printed_Text') || document.querySelector('input.Field');
                }

                if (action === 'shift') {
                    toggleShift();
                    return;
                }

                if (action === 'numbers') {
                    toggleNumbers();
                    return;
                }

                if (action === 'backspace') {
                    performBackspace(activeInput);
                    // update shared fields
                    try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                    return;
                }

                if (action === 'space') {
                    insertAtCursor(activeInput, ' ');
                    try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                    return;
                }

                if (action === 'enter') {
                    // prefer to submit login if focused on Printed_Text
                    const goBtn = document.getElementById('Open_Verification_Window');
                    if (goBtn && (activeInput && activeInput.id === 'Printed_Text')) {
                        goBtn.click();
                    } else {
                        insertAtCursor(activeInput, '\n');
                    }
                    try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                    return;
                }

                if (action === 'hide') {
                    keyboard.style.display = 'none';
                    keyboard.setAttribute('aria-hidden','true');
                    return;
                }

                if (key) {
                    insertAtCursor(activeInput, key);
                    // if shift was a single-use, turn it off after a key (common mobile behavior)
                    if (shift && !numbersMode) {
                        shift = false;
                        updateKeys();
                        document.getElementById('vk-shift').style.background = '';
                    }
                    // call existing update function for combined fields
                    try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                    return;
                }
            });

            // track focus changes from programmatic clicks or touch; keep keyboard visible
            document.addEventListener('touchend', (e) => {
                const focused = document.activeElement;
                if (focused && focused.matches && focused.matches(inputSelector)) {
                    activeInput = focused;
                    keyboard.style.display = 'block';
                    keyboard.setAttribute('aria-hidden','false');
                }
            });

            // small accessibility: hide keyboard if user taps outside inputs and keyboard
            document.addEventListener('click', (e) => {
                const el = e.target;
                if (el.closest && (el.closest(inputSelector) || el.closest('#VirtualKeyboard'))) return;
                // hide for desktops where not desired
                keyboard.style.display = 'none';
                keyboard.setAttribute('aria-hidden','true');
                activeInput = null;
            });

            // expose a small API
            window._virtualKeyboard = {
                show() { keyboard.style.display = 'block'; keyboard.setAttribute('aria-hidden','false'); },
                hide() { keyboard.style.display = 'none'; keyboard.setAttribute('aria-hidden','true'); },
                toggle() { keyboard.style.display = (keyboard.style.display === 'none' || keyboard.style.display === '') ? 'block' : 'none'; }
            };

        })();

        // Sound effects for virtual keyboard

        (function(){
            const soundTemplate = document.getElementById('vk-sound');
            if (!soundTemplate) return;

            // small audio pool to allow overlapping rapid keystrokes
            const POOL_SIZE = 4;
            const pool = [];
            for (let i = 0; i < POOL_SIZE; i++) {
                const a = soundTemplate.cloneNode(true);
                a.volume = 0.18;
                pool.push(a);
            }
            let idx = 0;

            const keyboard = document.getElementById('VirtualKeyboard');
            if (!keyboard) return;

            keyboard.addEventListener('click', (e) => {
                const key = e.target.closest('.vk-key');
                if (!key) return;

                // optionally skip playing for the "hide" control
                if (key.getAttribute('data-action') === 'hide') return;

                const audio = pool[idx];
                idx = (idx + 1) % POOL_SIZE;
                try {
                    audio.currentTime = 0;
                    audio.play().catch(()=>{});
                } catch (err) {}
            });
        })();

        
        </script>
    </div>

    <!-- UI system -->
    
    <!-- UI system -->

    <!-- Game system
        Profile
        Wallet
        
        market


    -->

    <!-- Main -->
    <div class="Disclaimer" id="Disclaimer">
        <div class="Disclaimer_Window">
            <p style=" position: absolute; top: 40px; width: 250px; color: var(--Main_Text_Color); font-size: 12px; text-align: center;">This web app is ment for phones and some tablets, but mostly phones. The UI nor the website wouldn't work on desktops and laptops </p>
            <button id="Close_Disclaimer" style="position: absolute; bottom: 20px; width: 150px; height: 30px; font-size: var(--Main_Text);">Accept</button>
        </div>
    </div>
    <div class="On_Button">
        <button id="Full_Screen_Button" style="width: 80px; height: 80px;"><img src="/Images/Icons/power_settings_new_24dp_1F1F1F.svg" alt=""></button>
    </div>       

    <div class="Progress_Bar" id="Progress_Bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
        <div id="Progress_Fill" class="Progress_Fill"></div>
        <span id="Progress_Label" class="Progress_Label">0%</span>
    </div>

    <div class="Login" id="Login">
        <div class="Window Login_Window" style="width: 300px; height: 460px;">
            <div class="Window_Header">
                <p class="Title">Log in</p>
                <button class="Close_Button" id="Close_Login_Button"></button>
            </div>
            <div class="Content">
                <p style="color: var(--Main_Text_Color); position: absolute; top: 40px; left: 20px; font-size: var(--Main_Text);">This uses the crypto hash SHA-256 algoritm to secure your account, just use your email address and name below to login.</p>

                <div class="Main">
                    <div class="Inputs">
                        <output class="Login_SHA-256_Output" id="Login_SHA-256_Output" aria-placeholder="Sha-256 Hash"></output>
                        <output class="Field" id="Printed_Text" type="text" style="width: 100%; height: 30px;" placeholder="Credentials"></output>
                    </div>
                    <div class="Buttons">
                        <button class="" id="Open_Verification_Window" style="width: 100%; height: 30px;">Login</button>
                        <button class="" id="Open_Signup_Window" style="width: 100%; height: 30px;">Sign Up</button>
                    </div>
                </div>
                <div class="Manual">
                    <div class="Hash_Name">
                        <input id="Hash_First_Name" class="Field" type="text" style="width: 100%; height: 30px;" placeholder="First Name">
                        <input id="Hash_Last_Name" class="Field" type="text" style="width: 100%; height: 30px;" placeholder="Last Name">
                    </div>
                    
                    <input id="Hash_Password" class="Field" type="text" style="width: 100%; height: 30px;" placeholder="Password">
                    <button class="" id="Open_Forgot_Password" style="width: 100%; height:30px;">Forgot Password?</button>
                </div>
            </div>
        </div>
        <div class="Close_Login_Menu" id="Close_Login_Menu">
            <div class="Menu_Container">
                <button class="" id="Exit_Page" style="width: 100%; height: 30px;">Exit page</button>
                <button class="" id="Revert_Back_To_Login" style="width: 100%; height: 30px;">Revert back to login</button>
            </div>
        </div>
        <div class="Window Signup_Window" style="width: 300px; height: 600px;">
            <div class="Window_Header">
                <p class="Title">Sign up</p>
                <button class="Close_Button" id="Close_Signup_Window"></button>
                <button class="Max_Size_Button" id="Maximize_Signup_Window"></button>
            </div>
            <div class="Content">
                <div class="Main_Title">
                    <p>Sign up</p>
                </div>
                <div class="Signup_Profile">
                    <div class="Signup_Profile_Bubble">
                        <img id="Signup_Profile_Options_Button" src="/Images/Profile Pics/man-user-circle-icon.png" alt="">
                    </div>
                    <div class="Signup_Profile_Name">
                        <p>John Doe</p>
                    </div>
                </div>
                <div class="Signup_Wallpaper">
                    <div class="Signup_Wallpaper_Container">
                        <img src="/Images/Wallpaper/1bf2a5457e255dba1b0e2e37076b4342.jpg" alt="">
                    </div>
                    <button class="Get_Signup_Wallpaper" id="Get_Signup_Wallpaper" style="width: 100%; height: 30px;">Upload Wallpaper</button>
                </div>
                <div class="Inputs">
                    <div class="First_Basic_Inputs">
                        <div class="Title">
                            <p style="color: var(--Main_Text_Color); font-size: var(--Main_Text);">Use the fields below to create your account, the SHA-256 hash will be generated from the data you input.</p>
                        </div>
                        <div class="Hash_Output">
                        <output class="Signup_SHA-256_Output" id="Signup_SHA-256_Output" aria-placeholder="Sha-256 Hash"></output>
                        </div>
                        <div class="Name">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="First Name">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Last Name">
                        </div>
                        <div class="Signup_Password">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Password">
                        </div>
                    </div>
                    <div class="Second_Basic_Inputs">
                        <div class="Title">
                            <p style="color: var(--Main_Text_Color); font-size: var(--Main_Text);">This is your backup data, incase you lose your password, you can rely on your secondary information to find your password.</p>
                        </div>
                        <div class="Hash_Output">
                        <output class="Signup_SHA-256_Output" id="Signup_SHA-256_Output" aria-placeholder="Sha-256 Hash"></output>
                        </div>
                        <div class="Name">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="First Name">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Last Name">
                        </div>
                        <div class="Information_1">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Data of birth">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Place of birth">
                        </div>
                        <div class="Information_2">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Information_1">
                            <input class="Field" id="" type="text" style="width: 100%; height: 30px;" placeholder="Information_2">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="Window Verification_Window" id="Verification_Window" style="width: 200px; height: 300px;">
            <div class="Window_Header">
                <p class="Title">Verification</p>
                <button class="Close_Button" id="Close_Verification_Window"></button>
            </div>
            <div class="Content">
                <div class="Verification_Window_Profile">
                    <img src="/Images/Profile Pics/man-user-circle-icon.png" alt="">
                </div>
                <div class="Data">
                    <span>Verification Success</span>
                    <span style="font-size: var(--Main_Text);">04 : 30</span>
                </div>
                <div class="Buttons">
                    <button style="width: calc(100% - 40px); height: 30px;">Go on</button>
                </div>
            </div>
        </div>
    </div>
    <div class="Dropdowns">
        <div class="Signup_Profile_Options">
            <div class="Dropdown_Window Signup_Profile_Options_Dropdown">
                <button class="Dropdown_Window_Button" id="" style="width: 100%; height: 30px;">View Picture</button>
                <button class="Dropdown_Window_Button" id="Open_Signup_Upload_Profile_Dialog" style="width: 100%; height: 30px;">Edit Picture</button>
            </div>
        </div>
    </div>
    <div class="Popup_Dialogs_Layer1">
        <div class="Window Signup_Upload_Profile_Dialog" style="width: 200px; height: 200px;">
            <div class="Window_Header">
                <p class="Title">Upload Profile Picture</p>
                <button class="Close_Button" id="Close_Signup_Upload_Profile_Dialog"></button>
            </div>
            <div class="Content">
                <div class="Signup_Upload_Profile_Dialog_Profile_Pic">
                    <img src="/Images/Profile Pics/man-user-circle-icon.png" alt="">
                </div>
                <div class="Buttons">
                    <button id="Signup_Get_Picture_From_Computer" style="width: 100%; height: 30px;">Get Profile</button>
                    <button id="Signup_Set_Picture" style="width: 100%; height: 30px;">Set Profile</button>
                </div>
            </div>
        </div>
        <div class="Window Forgot_Password_Dialog" style="width: 300px; height: 340px;">
            <div class="Window_Header">
                <p class="Title">Forgot Password</p>
                <button class="Close_Button" id="Close_Forgot_Password_Dialog"></button>
            </div>
            <div class="Content">
                <div class="Description">
                    <p>Fill out the bottom fields to help recover your password. This uses a Sha-256 hash to hide your password</p>
                </div>
                <div class="Forgotpassword_Output_Hash">
                     <output class="Forgotpassword_SHA-256_Output" id="Forgotpassword_SHA-256_Output" aria-placeholder="Sha-256 Hash"></output>
                     <button class="" id="Open_Forgot_Password_Show_Password_Dialog" style="width: 100%; height: 30px;">Get Password</button>
                </div>
                <div class="Forgotpassword_Inputs">
                    <div class="Name">
                        <input class="Field" id="Forgotpassword_First_Name" type="text" style="width: 100%; height: 30px;" placeholder="First Name">
                        <input class="Field" id="Forgotpassword_Last_Name" type="text" style="width: 100%; height: 30px;" placeholder="Last Name">
                    </div>
                    <div class="Information_1">
                        <input class="Field" id="Forgotpassword_First_Name" type="text" style="width: 100%; height: 30px;" placeholder="First Name">
                        <input class="Field" id="Forgotpassword_Last_Name" type="text" style="width: 100%; height: 30px;" placeholder="Last Name">
                    </div>
                    <div class="Information_2">
                        <input class="Field" id="Forgotpassword_First_Name" type="text" style="width: 100%; height: 30px;" placeholder="First Name">
                        <input class="Field" id="Forgotpassword_Last_Name" type="text" style="width: 100%; height: 30px;" placeholder="Last Name">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="Popup_Dialogs_Layer2">
        
    </div>
    <div class="Popup_Dialogs_Layer3">

    </div>
    <div class="Popup_Dialogs_Layer4">
        
    </div>
    <div class="Popup_Dialogs_Layer5">

    </div>
    <div class="Fullscreen_Dialogs_Layer1">
        <div class="Fullscreen_Dialog Revert_To_Fullscreen_Dialog" style="display: none;">
            <div class="Buttons">
                <button class="" id="Revert_To_Fullscreen" style="width: 100%; height: 30px;">Revert to fullscreen</button>
                <button class="" id="Exit_App_Page" style="width: 100%; height: 30px;">Exit page</button>
            </div>
        </div>
        <div class="Fullscreen_Dialog Maps_Dialog" style="display: none;">
            
        </div> 
    </div>
    <div class="Fullscreen_Dialogs_Layer2">
        <div class="Fullscreen_Dialog Forgot_Password_Show_Password_Dialog">
            <div class="Fields">
                <p>Your password is:</p>
                <p class="Recovered_Password" id="Recovered_Password">Password</p>
            </div>
            <div class="Close_Button">
                <button class="" id="Close_Forgot_Password_Show_Password_Dialog" style="width: 200px; height: 30px;">Close</button>
            </div>
        </div>
    </div>
    <div class="Fullscreen_Dialogs_Layer3">

    </div>
</body>

<!-- This is where you add the behaviors of the elements -->

<script>

    //First

    // Disable native Android/iOS soft keyboard for tracked inputs and rely on the in-page virtual keyboard.
    // Place this where the placeholder was.
    (function(){
        const selector = 'input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field';
        const inputs = Array.from(document.querySelectorAll(selector));
        if (!inputs.length) return;

        // Apply attributes that prevent the on-screen keyboard on modern mobile browsers
        inputs.forEach(el => {
            try {
                el.setAttribute('inputmode', 'none'); // Chrome/Android honor this
                el.readOnly = true;                    // broad fallback to stop keyboard
                el.setAttribute('aria-readonly', 'true');
            } catch (e) {}

            // On touchstart we prevent the default that might trigger IME and focus programmatically.
            // Programmatic focus on a readonly/inputmode=none input will not open the soft keyboard,
            // but keeps the element focused so the virtual keyboard can operate.
            el.addEventListener('touchstart', (ev) => {
                ev.preventDefault();
                try { el.focus(); } catch(e) {}
            }, { passive: false });

            // Allow mouse users to focus normally (desktop)
            el.addEventListener('mousedown', () => {
                try { el.focus(); } catch(e) {}
            });
        });

        // Small API to toggle native keyboard behavior if you ever need it
        window._nativeKeyboardControl = {
            disable() {
                document.querySelectorAll(selector).forEach(el => {
                    try { el.setAttribute('inputmode','none'); el.readOnly = true; el.setAttribute('aria-readonly','true'); } catch(e){}
                });
            },
            enable() {
                document.querySelectorAll(selector).forEach(el => {
                    try { el.removeAttribute('inputmode'); el.readOnly = false; el.removeAttribute('aria-readonly'); } catch(e){}
                });
            }
        };
    })();


    (function(){
        // Make the in-page VirtualKeyboard act like the native keyboard:
        // - prevent the OS soft keyboard from opening
        // - show/hide the virtual keyboard on focus/blur
        // - allow hardware keyboards to type into readonly inputs via synthetic handling

        const selector = 'input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field';
        const keyboard = document.getElementById('VirtualKeyboard');
        if (!keyboard) return;

        let activeInput = null;
        keyboard.setAttribute('aria-hidden','true');
        keyboard.style.display = 'none';

        // helper to dispatch input events
        function dispatchInput(el) {
            try { el.dispatchEvent(new Event('input', { bubbles: true })); } catch(e){}
        }

        function insertAtCursor(el, text) {
            if (!el) return;
            if (typeof el.selectionStart === 'number') {
                const start = el.selectionStart;
                const end = el.selectionEnd;
                const value = el.value || '';
                el.value = value.slice(0, start) + text + value.slice(end);
                const pos = start + text.length;
                el.selectionStart = el.selectionEnd = pos;
                dispatchInput(el);
            } else {
                el.value = (el.value || '') + text;
                dispatchInput(el);
            }
            try { el.focus(); } catch(e){}
        }

        function performBackspace(el) {
            if (!el) return;
            if (typeof el.selectionStart === 'number') {
                const start = el.selectionStart;
                const end = el.selectionEnd;
                if (start === end && start > 0) {
                    const value = el.value || '';
                    el.value = value.slice(0, start - 1) + value.slice(end);
                    el.selectionStart = el.selectionEnd = start - 1;
                } else if (start !== end) {
                    const value = el.value || '';
                    el.value = value.slice(0, start) + value.slice(end);
                    el.selectionStart = el.selectionEnd = start;
                }
                dispatchInput(el);
            } else {
                el.value = (el.value || '').slice(0, -1);
                dispatchInput(el);
            }
            try { el.focus(); } catch(e){}
        }

        // prepare tracked inputs to avoid native IME
        function prepareInputs() {
            const els = Array.from(document.querySelectorAll(selector));
            els.forEach(el => {
                try {
                    // prevent most mobile browsers from showing IME
                    el.setAttribute('inputmode', 'none');
                    el.readOnly = true;
                    el.setAttribute('aria-readonly','true');
                } catch(e){}
                // on touchstart, prevent default (which can trigger IME) and focus programmatically
                el.addEventListener('touchstart', (ev) => {
                    ev.preventDefault();
                    try { el.focus(); } catch(e){}
                }, { passive: false });

                // desktop mouse should just focus normally (no preventDefault)
                el.addEventListener('mousedown', (ev) => {
                    try { el.focus(); } catch(e){}
                });

                // ensure focus event shows virtual keyboard
                el.addEventListener('focus', () => {
                    activeInput = el;
                    keyboard.style.display = 'block';
                    keyboard.setAttribute('aria-hidden','false');
                    // place caret at end if possible
                    try {
                        const len = (el.value || '').length;
                        el.selectionStart = el.selectionEnd = len;
                    } catch(e){}
                });

                // on blur, schedule hide unless keyboard or another tracked input will receive focus
                el.addEventListener('blur', () => {
                    setTimeout(() => {
                        const af = document.activeElement;
                        if (!af) { hideKeyboard(); return; }
                        if (af.closest && (af.closest(selector) || af.closest('#VirtualKeyboard'))) return;
                        hideKeyboard();
                    }, 50);
                });
            });
        }

        function showKeyboardFor(el){
            if (!el) return;
            activeInput = el;
            try { el.focus(); } catch(e){}
            keyboard.style.display = 'block';
            keyboard.setAttribute('aria-hidden','false');
        }

        function hideKeyboard(){
            keyboard.style.display = 'none';
            keyboard.setAttribute('aria-hidden','true');
            activeInput = null;
        }

        // click outside inputs/keyboard hides it (desktop-friendly)
        document.addEventListener('click', (e) => {
            const el = e.target;
            if (el.closest && (el.closest(selector) || el.closest('#VirtualKeyboard'))) return;
            hideKeyboard();
        });

        // touch outside keyboard hide
        document.addEventListener('touchstart', (e) => {
            const el = e.target;
            if (el.closest && (el.closest(selector) || el.closest('#VirtualKeyboard'))) return;
            // small delay so focus events can run
            setTimeout(hideKeyboard, 50);
        }, { passive: true });

        // Ensure newly added inputs are handled (basic live watch)
        const mo = new MutationObserver(() => prepareInputs());
        mo.observe(document.body, { childList: true, subtree: true });

        // initial run
        prepareInputs();

        // Allow hardware keyboards to type into the readonly inputs by synthesizing edits.
        // This is necessary because readOnly prevents native IME/OS keyboard but also blocks hardware input.
        document.addEventListener('keydown', (ev) => {
            if (!activeInput) return;
            // ignore modifier-only combos
            if (ev.metaKey || ev.ctrlKey || ev.altKey) return;
            // printable characters: single character keys
            if (ev.key.length === 1) {
                ev.preventDefault();
                insertAtCursor(activeInput, ev.key);
                try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                return;
            }
            // handle common editing keys
            if (ev.key === 'Backspace') {
                ev.preventDefault();
                performBackspace(activeInput);
                try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                return;
            }
            if (ev.key === 'Enter') {
                ev.preventDefault();
                // if there's an enter handler on the page (like login button) attempt to trigger it
                const goBtn = document.getElementById('Open_Verification_Window');
                if (goBtn && activeInput && activeInput.id === 'Printed_Text') {
                    goBtn.click();
                } else {
                    insertAtCursor(activeInput, '\n');
                }
                try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
                return;
            }
            if (ev.key === 'ArrowLeft') {
                // move caret left
                try {
                    const pos = activeInput.selectionStart || 0;
                    activeInput.selectionStart = activeInput.selectionEnd = Math.max(0, pos - 1);
                } catch(e){}
                return;
            }
            if (ev.key === 'ArrowRight') {
                try {
                    const pos = activeInput.selectionStart || 0;
                    activeInput.selectionStart = activeInput.selectionEnd = Math.min((activeInput.value || '').length, pos + 1);
                } catch(e){}
                return;
            }
        });

        // expose small API to control keyboard programmatically
        window._virtualKeyboard = {
            showFor(el) { showKeyboardFor(el || document.querySelector(selector)); },
            show() { keyboard.style.display = 'block'; keyboard.setAttribute('aria-hidden','false'); },
            hide() { hideKeyboard(); },
            toggle() { keyboard.style.display = (keyboard.style.display === 'none' || keyboard.style.display === '') ? 'block' : 'none'; }
        };
    })();

    (function(){
        document.addEventListener('DOMContentLoaded', () => {
            const vk = document.getElementById('VirtualKeyboard');
            if (!vk) return;

            // ensure known initial state
            vk.style.display = 'none';
            vk.setAttribute('aria-hidden', 'true');
            vk.setAttribute('role','application');
            // helper to show/hide keyboard reliably
            function showKeyboardFor(el) {
                if (!el) return;
                try { el.focus(); } catch (e) {}
                vk.style.display = 'block';
                vk.setAttribute('aria-hidden', 'false');
                // ensure any existing API stays in sync
                try { window._virtualKeyboard && window._virtualKeyboard.showFor && window._virtualKeyboard.showFor(el); } catch (e) {}
            }
            function hideKeyboard() {
                vk.style.display = 'none';
                vk.setAttribute('aria-hidden', 'true');
                try { window._virtualKeyboard && window._virtualKeyboard.hide && window._virtualKeyboard.hide(); } catch (e) {}
            }

            // activate keyboard for the primary tracked input if present
            const primary = document.getElementById('Printed_Text') || document.querySelector('input.Field');
            if (primary) {
                // give a brief delay so other init code runs first
                setTimeout(() => showKeyboardFor(primary), 120);
            }

            // expose a small global helper to programmatically attach keyboard to any element
            window.activateVirtualKeyboardFor = showKeyboardFor;
            window.deactivateVirtualKeyboard = hideKeyboard;

            // hide keyboard when login/verification proceeds
            const openVerBtn = document.getElementById('Open_Verification_Window');
            if (openVerBtn) openVerBtn.addEventListener('click', hideKeyboard);

            // keep keyboard visible when a tracked input gets focus (covers dynamic inputs)
            document.addEventListener('focusin', (ev) => {
                const t = ev.target;
                if (!t) return;
                if (t.matches && t.matches('input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field')) {
                    showKeyboardFor(t);
                }
            });

            // click/touch outside inputs + keyboard hides it (desktop-friendly)
            document.addEventListener('click', (ev) => {
                if (ev.target.closest && (ev.target.closest('input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field') || ev.target.closest('#VirtualKeyboard'))) return;
                hideKeyboard();
            });
            document.addEventListener('touchstart', (ev) => {
                if (ev.target.closest && (ev.target.closest('input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field') || ev.target.closest('#VirtualKeyboard'))) return;
                // slight delay to allow focus events
                setTimeout(hideKeyboard, 50);
            }, { passive: true });

            // keep keyboard visible when screen resizes if an input is focused
            window.addEventListener('resize', () => {
                const af = document.activeElement;
                if (af && af.matches && af.matches('input.Field, #Printed_Text, #Hash_Name, #Password, textarea.Field')) {
                    vk.style.display = 'block';
                    vk.setAttribute('aria-hidden', 'false');
                }
            });
        });
    })();

    (function(){
        const keyboard = document.getElementById('VirtualKeyboard');
        if (!keyboard) return;

        // improve touch responsiveness
        keyboard.style.touchAction = 'none';
        keyboard.style.userSelect = 'none';

        // add a small active style (some browsers don't apply :active reliably on touch)
        const s = document.createElement('style');
        s.textContent = `
            .vk-key.active {
                transform: translateY(1px) !important;
                background: var(--Text_Input_Field-Actove) !important;
            }
        `;
        document.head.appendChild(s);

        let activeKey = null;
        let repeatTimeout = null;
        let repeatInterval = null;
        let repeatStarted = false;

        function clearRepeat() {
            if (repeatTimeout) { clearTimeout(repeatTimeout); repeatTimeout = null; }
            if (repeatInterval) { clearInterval(repeatInterval); repeatInterval = null; }
            repeatStarted = false;
        }

        keyboard.addEventListener('pointerdown', (ev) => {
            const btn = ev.target.closest('.vk-key');
            if (!btn) return;
            ev.preventDefault();

            activeKey = btn;
            btn.classList.add('active');
            try { btn.setPointerCapture && btn.setPointerCapture(ev.pointerId); } catch(e){}

            // long-press/backspace repeat: begin repeating after a short delay
            if (btn.getAttribute('data-action') === 'backspace') {
                repeatTimeout = setTimeout(() => {
                    repeatStarted = true;
                    repeatInterval = setInterval(() => {
                        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
                    }, 80);
                }, 350);
            }
        }, { passive: false });

        function endPointerInteraction(ev, cancel) {
            if (!activeKey) return;
            try { activeKey.releasePointerCapture && activeKey.releasePointerCapture(ev && ev.pointerId); } catch(e){}
            activeKey.classList.remove('active');

            // if user didn't trigger repeating behaviour, dispatch a click
            if (!repeatStarted && !cancel) {
                // ensure pointer ended over the same key (avoid accidental clicks when dragging away)
                if (ev && typeof ev.clientX === 'number' && typeof ev.clientY === 'number') {
                    const under = document.elementFromPoint(ev.clientX, ev.clientY);
                    if (!under || !under.closest || !under.closest('.vk-key')) {
                        clearRepeat();
                        activeKey = null;
                        return;
                    }
                }
                activeKey.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
            }

            clearRepeat();
            activeKey = null;
        }

        keyboard.addEventListener('pointerup', (ev) => {
            endPointerInteraction(ev, false);
        });

        keyboard.addEventListener('pointercancel', (ev) => {
            endPointerInteraction(ev, true);
        });

        // if the pointer leaves the key while pressed, cancel the pending click/repeat
        keyboard.addEventListener('pointermove', (ev) => {
            if (!activeKey) return;
            // if pointer moved far outside the key, cancel visual state
            const rect = activeKey.getBoundingClientRect();
            const pad = 16; // small slack
            if (ev.clientX < rect.left - pad || ev.clientX > rect.right + pad || ev.clientY < rect.top - pad || ev.clientY > rect.bottom + pad) {
                // when moving away, remove active class but keep repeat cancelled
                activeKey.classList.remove('active');
                clearRepeat();
            } else {
                activeKey.classList.add('active');
            }
        });

        // prevent context menu on long touch and avoid blurring
        keyboard.addEventListener('contextmenu', (e) => e.preventDefault());

        // keyboard should not blur tracked inputs when touched
        keyboard.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    })();

    (function(){
        // Show a dialog asking the user to revert to fullscreen when the page exits fullscreen.
        function isFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
        }

        function centerDialog(dialog){
            if(!dialog) return;
            dialog.style.display = 'flex';
            dialog.style.position = 'fixed';
            dialog.style.left = '50%';
            dialog.style.top = '50%';
            dialog.style.transform = 'translate(-50%, -50%)';
            dialog.style.zIndex = String(99999);
            try { if (typeof bringToFront === 'function') bringToFront(dialog); } catch(e){}
            // focus first button for accessibility
            const btn = dialog.querySelector('button');
            if (btn && typeof btn.focus === 'function') btn.focus();
        }

        function hideDialog(dialog){
            if(!dialog) return;
            dialog.style.display = 'none';
            dialog.style.transform = '';
        }

        async function requestFullscreen() {
            const el = document.documentElement;
            try {
                if (el.requestFullscreen) await el.requestFullscreen();
                else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
                else if (el.msRequestFullscreen) await el.msRequestFullscreen();
            } catch(e){ /* ignore */ }
        }

        function onFsChange(){
            const dialog = document.querySelector('.Fullscreen_Dialog.Revert_To_Fullscreen_Dialog');
            if (!dialog) return;
            if (!isFullscreen()) {
                centerDialog(dialog);
            } else {
                hideDialog(dialog);
            }
        }

        document.addEventListener('fullscreenchange', onFsChange);
        document.addEventListener('webkitfullscreenchange', onFsChange);
        document.addEventListener('msfullscreenchange', onFsChange);

        // Wire up the dialog buttons if present
        document.addEventListener('click', (e) => {
            const btn = e.target;
            if (!btn) return;
            if (btn.id === 'Revert_To_Fullscreen') {
                requestFullscreen().then(()=> {
                    const d = document.querySelector('.Fullscreen_Dialog.Revert_To_Fullscreen_Dialog');
                    if (d) hideDialog(d);
                }).catch(()=>{});
            } else if (btn.id === 'Exit_App_Page') {
                // best-effort: try to close the page
                try { window.close(); } catch(e){}
            }
        });

        // If page starts not-fullscreen and dialog element exists, ensure it's hidden initially
        document.addEventListener('DOMContentLoaded', () => {
            const dialog = document.querySelector('.Fullscreen_Dialog.Revert_To_Fullscreen_Dialog');
            if (dialog) {
                if (!isFullscreen()) dialog.style.display = 'none';
                else dialog.style.display = 'none';
            }
        });
    })();

    //Start

    (function(){
        const fsBtn = document.getElementById('Full_Screen_Button');
        const docEl = document.documentElement;
        if (!fsBtn) return;

        async function enterFullscreen() {
            try {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                    return; // already fullscreen
                }
                if (docEl.requestFullscreen) {
                    await docEl.requestFullscreen();
                } else if (docEl.webkitRequestFullscreen) {
                    await docEl.webkitRequestFullscreen();
                } else if (docEl.msRequestFullscreen) {
                    await docEl.msRequestFullscreen();
                }
            } catch (err) {
                console.warn('Failed to enter fullscreen:', err);
            }
        }

        fsBtn.addEventListener('click', (e) => {
            enterFullscreen();
        });
    })();

    (function(){
        const bar = document.getElementById('Progress_Bar');
        const fill = document.getElementById('Progress_Fill');
        const label = document.getElementById('Progress_Label');
        const btn = document.getElementById('Full_Screen_Button');
        if (!bar || !fill || !label) return;

        // remember original display so we can restore it
        const originalBtnDisplay = btn ? (btn.style.display || '') : '';

        // start hidden
        bar.style.display = 'none';

        // Expose a simple API: window.setProgress(percent)
        window.setProgress = function(percent){
            const p = Math.max(0, Math.min(100, Math.round(percent)));
            fill.style.width = p + '%';
            bar.setAttribute('aria-valuenow', p);
            label.textContent = p + '%';
        };

        let progressInterval = null;

        function startProgressDemo() {
            clearProgress();
            // hide the fullscreen button while progress runs
            if (btn) btn.style.display = 'none';

            bar.style.display = 'flex';
            let demo = 0;
            window.setProgress(0);
            progressInterval = setInterval(() => {
                demo += 8;
                window.setProgress(demo);
                if (demo >= 100) {
                    // finish: stop interval, show final state and restore button
                    clearInterval(progressInterval);
                    progressInterval = null;
                    window.setProgress(100);
                    if (btn) btn.style.display = originalBtnDisplay;
                    return;
                }
            }, 100);
        }

        function clearProgress() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            // keep final state at 100 if finished, otherwise reset to 0 when stopping manually
            if (bar.style.display === 'none') {
                window.setProgress(0);
            }
        }

        function stopAndHideProgress() {
            clearProgress();
            window.setProgress(0);
            bar.style.display = 'none';
            // restore fullscreen button when progress is hidden/stopped
            if (btn) btn.style.display = originalBtnDisplay;
        }

        // If the fullscreen button exists, start progress when it's pressed.
        if (btn) {
            btn.addEventListener('click', () => {
                // show and begin progress animation when button is pressed
                startProgressDemo();
            });
        }

        // Hide progress bar when fullscreen is exited. Listen for vendor-prefixed events too.
        function onFullscreenChange() {
            const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            if (!isFs) {
                stopAndHideProgress();
            }
            // if entering fullscreen via other means, keep showing progress (no-op)
        }

        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);
        document.addEventListener('msfullscreenchange', onFullscreenChange);

        // Expose control if other code wants to show/hide/reset
        window._progressControl = { start: startProgressDemo, stop: stopAndHideProgress };
    })();

    (function(){
        const progressBar = document.getElementById('Progress_Bar');
        if (!progressBar) return;
        const fsBtn = document.getElementById('Full_Screen_Button');

        function openLoginWindow() {
            const loginContainer = document.querySelector('.Login');
            const loginWindow = document.querySelector('.Login_Window');
            if (!loginContainer || !loginWindow) return;

            // show container and window
            loginContainer.style.display = 'flex';
            loginWindow.style.display = 'flex';
            loginWindow.style.position = 'absolute';

            // center the window
            const winRect = loginWindow.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();
            loginWindow.style.left = Math.max(0, (bodyRect.width - winRect.width) / 2) + 'px';
            loginWindow.style.top = Math.max(0, (bodyRect.height - winRect.height) / 2) + 'px';

            // focus first interactive element if present
            const first = loginWindow.querySelector('input, button, [tabindex]');
            if (first && typeof first.focus === 'function') first.focus();

            // hide fullscreen button when progress reaches 100%
            if (fsBtn) fsBtn.style.display = 'none';
        }

        // Monkey-patch window.setProgress if it exists so we trigger when it reaches 100.
        if (typeof window.setProgress === 'function') {
            const origSet = window.setProgress;
            window.setProgress = function(percent) {
                try {
                    origSet(percent);
                } catch (e) {
                    // still attempt to proceed
                    try { origSet(Number(percent)); } catch (_) {}
                }
                const p = Math.max(0, Math.min(100, Math.round(Number(percent) || 0)));
                if (p >= 100) openLoginWindow();
            };
        }

        // Fallback: observe aria-valuenow changes on the progress bar
        const obs = new MutationObserver(muts => {
            for (const m of muts) {
                if (m.type === 'attributes' && m.attributeName === 'aria-valuenow') {
                    const v = Number(progressBar.getAttribute('aria-valuenow') || 0);
                    if (v >= 100) {
                        openLoginWindow();
                        obs.disconnect();
                        break;
                    }
                }
            }
        });
        obs.observe(progressBar, { attributes: true });
    })();

    (function(){
        const bar = document.getElementById('Progress_Bar');
        if (!bar) return;

        const origSet = window.setProgress;
        window.setProgress = function(percent) {
            try { if (typeof origSet === 'function') origSet(percent); } catch (e) {}
            const p = Math.max(0, Math.min(100, Math.round(Number(percent) || 0)));
            if (p >= 100) {
                // let the fill transition complete, then hide
                setTimeout(() => { bar.style.display = 'none'; }, 350);
            }
        };
    })();

    (function(){
        const closeLoginBtn = document.getElementById('Close_Login_Button');
        const closeMenu = document.getElementById('Close_Login_Menu');
        const revertBtn = document.getElementById('Revert_Back_To_Login');
        const exitBtn = document.getElementById('Exit_Page');

        if (!closeLoginBtn || !closeMenu) return;

        closeLoginBtn.addEventListener('click', () => {
            // show the modal/menu overlay
            closeMenu.style.display = 'flex';
            // bring overlay to front if bringToFront is available
            try { if (typeof bringToFront === 'function') bringToFront(closeMenu); } catch(e){}
            // focus first button inside menu for keyboard users
            const first = closeMenu.querySelector('button');
            if (first && typeof first.focus === 'function') first.focus();
        });

        // revert back to login (hide the menu)
        if (revertBtn) {
            revertBtn.addEventListener('click', () => {
                closeMenu.style.display = 'none';
                const loginWin = document.querySelector('.Login_Window');
                if (loginWin) try { if (typeof bringToFront === 'function') bringToFront(loginWin); } catch(e){}
            });
        }

        async function exitFullscreenIfNeeded() {
            try {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                    if (document.exitFullscreen) await document.exitFullscreen();
                    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
                    else if (document.msExitFullscreen) await document.msExitFullscreen();
                }
            } catch (e) {
                // ignore
            }
        }

        // optional: attempt to close the page on Exit_Page click (best-effort)
        if (exitBtn) {
            exitBtn.addEventListener('click', async () => {
                // exit fullscreen first
                await exitFullscreenIfNeeded();
                // hide the menu
                try { closeMenu.style.display = 'none'; } catch(e){}
                // then attempt to close the window
                try { window.close(); } catch (e) {}
            });
        }
    })();

    (function(){
        const exitBtn = document.getElementById('Exit_Page');
        const login = document.getElementById('Login');
        const fsBtn = document.getElementById('Full_Screen_Button');
        if (!exitBtn) return;

        exitBtn.addEventListener('click', () => {
            // hide login container
            if (login) login.style.display = 'none';
            // ensure full screen button is visible again
            if (fsBtn) fsBtn.style.display = '';
        });
    })();

    
    // Wallpaper Image Slider

    // Wallpaper cross-fade slideshow (fade-in between images)
    (function(){
        const imgList = Array.from(document.querySelectorAll('.Wallpaper .Img_List img'));
        if (!imgList.length) return;

        // ensure container and images are positioned for overlap
        const container = document.querySelector('.Wallpaper .Img_List');
        if (container) container.style.position = 'relative';

        imgList.forEach((img, i) => {
            img.style.position = 'absolute';
            img.style.top = '0';
            img.style.left = '0';
            img.style.width = '100dvw';
            img.style.height = '100dvh';
            img.style.objectFit = 'cover';
            img.style.opacity = i === 0 ? '1' : '0';
            img.style.transition = 'opacity 3000ms ease';
            img.style.zIndex = i === 0 ? '2' : '1';
            img.style.pointerEvents = 'none';
            // optionally ensure image decoded (preload)
            if (img.decode) img.decode().catch(()=>{});
        });

        // shuffle helper (Fisher-Yates) but keep existing first image visible after shuffle
        function shuffleImages(images) {
            for (let i = images.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                if (i === j) continue;
                const a = images[i], b = images[j];
                // swap DOM positions
                const parent = a.parentNode;
                parent.insertBefore(b, a);
                // swap array items
                [images[i], images[j]] = [images[j], images[i]];
            }
        }

        // optional: randomize order once
        shuffleImages(imgList);

        let currentIndex = 0;
        const fadeDuration = 1000; // ms
        const displayDuration = 9000; // ms (so total cycle ~10s)
        let timeoutId = null;
        let running = true;

        function crossfadeTo(nextIndex) {
            if (!running || nextIndex === currentIndex) return;
            const current = imgList[currentIndex];
            const next = imgList[nextIndex];

            // bring next above current
            next.style.zIndex = (parseInt(current.style.zIndex || '1') + 1).toString();
            next.style.opacity = '0';
            // force reflow so transition will run
            void next.offsetWidth;
            next.style.opacity = '1';

            // after fadeDuration, lower previous image z and set opacity to 0 for next cycles
            setTimeout(() => {
                current.style.opacity = '0';
                current.style.zIndex = '1';
                next.style.zIndex = '2';
                currentIndex = nextIndex;
            }, fadeDuration);
        }

        function scheduleNext() {
            timeoutId = setTimeout(() => {
                const nextIndex = (currentIndex + 1) % imgList.length;
                crossfadeTo(nextIndex);
                scheduleNext();
            }, displayDuration);
        }

        // Start loop
        scheduleNext();

        // expose controls if needed
        window._wallpaperSlideshow = {
            stop() { running = false; clearTimeout(timeoutId); },
            start() { if (!running) { running = true; scheduleNext(); } },
            next() { clearTimeout(timeoutId); crossfadeTo((currentIndex + 1) % imgList.length); scheduleNext(); },
            prev() { clearTimeout(timeoutId); crossfadeTo((currentIndex - 1 + imgList.length) % imgList.length); scheduleNext(); }
        };
    })();

    (function(){
        const container = document.querySelector('.Wallpaper .Img_List');
        if (!container) return;

        function fisherYatesShuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function shuffleWallpaperImagesRandomly() {
            const imgs = Array.from(container.querySelectorAll('img'));
            if (imgs.length <= 1) return;

            // detach and shuffle array
            fisherYatesShuffle(imgs);

            // re-append in shuffled order
            imgs.forEach((img, idx) => {
                container.appendChild(img);
                // ensure visual state: first image visible
                img.style.opacity = idx === 0 ? '1' : '0';
                img.style.zIndex = idx === 0 ? '2' : '1';
            });

            // Restart the slideshow if controller exists
            try {
                if (window._wallpaperSlideshow) {
                    window._wallpaperSlideshow.stop?.();
                    // Small timeout to let styles settle before starting
                    setTimeout(() => window._wallpaperSlideshow.start?.(), 50);
                }
            } catch (e) { /* ignore */ }
        }

        // expose for manual use
        window.shuffleWallpaperImagesRandomly = shuffleWallpaperImagesRandomly;

        // Shuffle once now to randomize starting order
        shuffleWallpaperImagesRandomly();

        // Optional: double-click the wallpaper area to reshuffle
        container.addEventListener('dblclick', () => shuffleWallpaperImagesRandomly());
    })();

    // UI Dragging Window
    
    // make windowElement var available for other functions below
    let windowElement = null;
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    const windows = Array.from(document.querySelectorAll('.Window'));

    windows.forEach(win => {
        const header = win.querySelector('.Window_Header');
        if (!header) return;

        header.addEventListener('mousedown', (e) => {
            windowElement = win;
            isDragging = true;
            const rect = windowElement.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            document.body.style.userSelect = 'none';
        });

        header.addEventListener('touchstart', (e) => {
            if (e.touches.length !== 1) return;
            windowElement = win;
            isDragging = true;
            const rect = windowElement.getBoundingClientRect();
            offsetX = e.touches[0].clientX - rect.left;
            offsetY = e.touches[0].clientY - rect.top;
            document.body.style.userSelect = 'none';
        });
    });

    // global mouse/touch handlers drive the active window
    document.addEventListener('mousemove', (e) => {
        if (!isDragging || !windowElement) return;
        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;
        // call existing setWindowPosition (uses global windowElement)
        setWindowPosition(x, y);
        windowElement.style.position = 'absolute';
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        windowElement = null;
        document.body.style.userSelect = '';
    });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging || !windowElement || e.touches.length !== 1) return;
        const x = e.touches[0].clientX - offsetX;
        const y = e.touches[0].clientY - offsetY;
        setWindowPosition(x, y);
        windowElement.style.position = 'absolute';
    });

    document.addEventListener('touchend', () => {
        isDragging = false;
        windowElement = null;
        document.body.style.userSelect = '';
    });

    // Snap to grid

    function snapToGrid(x, y, gridSize = 20) {
        const snappedX = Math.round(x / gridSize) * gridSize;
        const snappedY = Math.round(y / gridSize) * gridSize;
        return { x: snappedX, y: snappedY };
        
    }

    function setWindowPosition(x, y) {
        const snapped = snapToGrid(x, y);
        windowElement.style.left = snapped.x + 'px';
        windowElement.style.top = snapped.y + 'px';
    }
    
    function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
    }

    function setWindowPosition(x, y) {
        const snapped = snapToGrid(x, y);
        const winRect = windowElement.getBoundingClientRect();
        const bodyRect = document.body.getBoundingClientRect();
        const maxX = bodyRect.width - winRect.width;
        const maxY = bodyRect.height - winRect.height;
        windowElement.style.left = clamp(snapped.x, 0, maxX) + 'px';
        windowElement.style.top = clamp(snapped.y, 0, maxY) + 'px';
    }

    

    // bring active window forward (z-index stacking)
    let nextZIndex = 10;

    function bringToFront(el) {
        if (!el) return;
        el.style.zIndex = nextZIndex++;
    }

    // bring to front when any window is interacted with
    windows.forEach(win => {
        win.addEventListener('mousedown', () => bringToFront(win));
        win.addEventListener('touchstart', () => bringToFront(win));
    });


    // Disclaimer

    document.getElementById('Close_Disclaimer').addEventListener('click', function() {
        document.getElementById('Disclaimer').style.display = 'none';
    });

    // Login // Windows

    // Login / Verification window

    (function(){
        const openBtn = document.getElementById('Open_Verification_Window');
        const verification = document.getElementById('Verification_Window');
        const loginWindow = document.querySelector('.Login_Window');
        const loginContainer = document.querySelector('.Login');

        if (!openBtn || !verification) return;

        function centerAndShow(el) {
            el.style.display = 'flex';
            el.style.position = 'absolute';
            // center in body
            const rect = el.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();
            el.style.left = Math.max(0, (bodyRect.width - rect.width) / 2) + 'px';
            el.style.top = Math.max(0, (bodyRect.height - rect.height) / 2) + 'px';
            try { if (typeof bringToFront === 'function') bringToFront(el); } catch(e){}
        }

        openBtn.addEventListener('click', (e) => {
            // show verification window without hiding the login window
            centerAndShow(verification);

            // ensure login container remains visible (if needed)
            if (loginContainer) loginContainer.style.display = 'flex';

            // bring verification above the login window
            try { if (typeof bringToFront === 'function') bringToFront(verification); } catch(e){}
        });

        // close button: hide verification but keep login open
        const closeVerBtn = document.getElementById('Close_Verification_Window');
        if (closeVerBtn) {
            closeVerBtn.addEventListener('click', () => {
                verification.style.display = 'none';
                try { if (loginWindow) { loginWindow.style.display = 'flex'; bringToFront(loginWindow); } } catch(e){}
            });
        }
    })();

    // Login / Verification window behaviors

    (function(){
        function formatTime(d){
            // use locale-aware standard time (HH:MM:SS, includes AM/PM where appropriate)
            return d.toLocaleTimeString();
        }

        const timeEl = document.querySelector('.Login .Verification_Window .Data span:nth-of-type(2)');
        function refresh() {
            if (timeEl) timeEl.textContent = formatTime(new Date());
        }

        window.getCurrentTime = function() {
            const now = new Date();
            return { date: now, formatted: formatTime(now), iso: now.toISOString() };
        };

        refresh();
        setInterval(refresh, 1000);
    })();
    
    // Hash Display - Login

    (function(){
        function syncPrinted() {
            const printed = document.getElementById('Printed_Text');
            const first = document.getElementById('Hash_First_Name');
            const last = document.getElementById('Hash_Last_Name');
            const pass = document.getElementById('Hash_Password');
            if (!printed || !first || !last || !pass) return;
            const combined = [first.value || '', last.value || '', pass.value || ''].join(' ').trim();
            printed.value = combined;
            try { printed.dispatchEvent(new Event('input', { bubbles: true })); } catch(e){}
            try { if (typeof updateSHAField === 'function') updateSHAField(); } catch(e){}
        }

        ['Hash_First_Name','Hash_Last_Name','Hash_Password'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('input', syncPrinted);
            const mo = new MutationObserver(syncPrinted);
            mo.observe(el, { attributes: true, attributeFilter: ['value'] });
        });

        // initial sync
        setTimeout(syncPrinted, 0);
    })();

    (function(){
        async function computeSHA256Hex(str) {
            const enc = new TextEncoder();
            const data = enc.encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function updateSHAField() {
            const out = document.getElementById('Login_SHA-256_Output');
            if (!out) return;

            const printed = document.getElementById('Printed_Text')?.value || '';
            const first = document.getElementById('Hash_First_Name')?.value || '';
            const last  = document.getElementById('Hash_Last_Name')?.value || '';
            const pass  = document.getElementById('Hash_Password')?.value || '';

            // combine fields deterministically
            const combined = `${printed}|${first}|${last}|${pass}`;

            try {
                const hex = await computeSHA256Hex(combined);
                out.textContent = hex;
            } catch (e) {
                out.textContent = 'hash-error';
                console.error('SHA-256 failed', e);
            }
        }

        // expose for other code
        window.updateSHAField = updateSHAField;

        // wire up inputs to update on changes (virtual keyboard dispatches 'input')
        ['Printed_Text','Hash_First_Name','Hash_Last_Name','Hash_Password'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('input', updateSHAField);
            // also update on programmatic attribute changes
            const mo = new MutationObserver(updateSHAField);
            mo.observe(el, { attributes: true, attributeFilter: ['value'] });
        });

        // initial compute
        setTimeout(updateSHAField, 0);
    })();

    (function(){
        const out = document.getElementById('Login_SHA-256_Output');
        if (!out) return;

        const orig = window.updateSHAField || (async function(){});

        window.updateSHAField = async function(...args) {
            await orig.apply(this, args);
            const full = (out.textContent || '').toString();
            // keep full value for debugging / future use
            out.dataset.full = full;
            // display only first 32 characters
            out.textContent = full.slice(0, 32);
        };

        // recompute once to apply truncation to the current value
        setTimeout(() => { try { window.updateSHAField(); } catch(e){} }, 0);
    })();

    //Sign up Window

    (function(){
        const openBtn = document.getElementById('Open_Signup_Window');
        const signupWin = document.querySelector('.Signup_Window');
        const loginWin = document.querySelector('.Login_Window');

        if (!openBtn || !signupWin) return;

        function centerAndShow(el) {
            el.style.display = 'flex';
            el.style.position = 'absolute';
            // ensure layout measured before positioning
            const rect = el.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();
            el.style.left = Math.max(0, (bodyRect.width - rect.width) / 2) + 'px';
            el.style.top = Math.max(0, (bodyRect.height - rect.height) / 2) + 'px';
            try { if (typeof bringToFront === 'function') bringToFront(el); } catch (e) {}
        }

        openBtn.addEventListener('click', () => {
            // keep login window visible; just show signup on top
            centerAndShow(signupWin);
            try { if (typeof bringToFront === 'function') bringToFront(signupWin); } catch (e) {}

            // focus first interactive element inside signup for accessibility
            try {
                const first = signupWin.querySelector('input, button, [tabindex]');
                if (first && typeof first.focus === 'function') first.focus();
            } catch (e) {}
        });
    })();

    (function(){
        const closeBtn = document.getElementById('Close_Signup_Window');
        const signupWin = document.querySelector('.Signup_Window');
        const loginWin = document.querySelector('.Login_Window');

        if (!closeBtn) return;

        closeBtn.addEventListener('click', () => {
            if (signupWin) signupWin.style.display = 'none';
            if (loginWin) {
                loginWin.style.display = 'flex';
                try { bringToFront(loginWin); } catch (e) {}
            }
        });
    })();

    (function(){
        const btn = document.getElementById('Maximize_Signup_Window');
        const win = document.querySelector('.Signup_Window');
        if (!btn || !win) return;

        btn.addEventListener('click', () => {
            const isMax = win.dataset.maximized === '1';

            if (!isMax) {
                // Save current inline styles / geometry
                const rect = win.getBoundingClientRect();
                win.dataset.prevLeft = win.style.left || rect.left + 'px';
                win.dataset.prevTop = win.style.top || rect.top + 'px';
                win.dataset.prevWidth = win.style.width || rect.width + 'px';
                win.dataset.prevHeight = win.style.height || rect.height + 'px';
                win.dataset.prevPosition = win.style.position || getComputedStyle(win).position;

                // Maximize to cover viewport
                win.style.position = 'fixed';
                win.style.left = '0';
                win.style.top = '0';
                win.style.width = '100vw';
                win.style.height = '100vh';
                win.style.margin = '0';
                win.dataset.maximized = '1';

                btn.style.background = 'rgb(255,255,255)';
                try { bringToFront(win); } catch(e){}
            } else {
                // Restore previous state
                win.style.position = win.dataset.prevPosition || '';
                win.style.left = win.dataset.prevLeft || '';
                win.style.top = win.dataset.prevTop || '';
                win.style.width = win.dataset.prevWidth || '';
                win.style.height = win.dataset.prevHeight || '';
                win.style.margin = '';

                delete win.dataset.prevLeft;
                delete win.dataset.prevTop;
                delete win.dataset.prevWidth;
                delete win.dataset.prevHeight;
                delete win.dataset.prevPosition;
                win.dataset.maximized = '0';

                btn.style.background = '';
                try { bringToFront(win); } catch(e){}
            }
        });
    })();

    //Sign up Window //Dropdown

    (function(){
        const dropdown = document.querySelector('.Signup_Profile_Options_Dropdown');
        const bubble = document.querySelector('.Signup_Profile_Bubble');
        const toggleBtn = document.getElementById('Signup_Profile_Options_Button') || bubble;

        if (!dropdown || !bubble || !toggleBtn) return;

        // ensure dropdown is positioned absolutely on the page layer
        dropdown.style.position = 'absolute';
        dropdown.style.display = dropdown.style.display || 'none';
        dropdown.style.zIndex = dropdown.style.zIndex || '9999';

        function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

        function positionDropdown() {
            const bRect = bubble.getBoundingClientRect();
            const ddRect = dropdown.getBoundingClientRect();
            const vw = document.documentElement.clientWidth;
            const vh = document.documentElement.clientHeight;

            // Preferred: place dropdown below and right-aligned to the bubble
            let left = bRect.right - ddRect.width;
            let top  = bRect.bottom + 8; // small gap

            // If there's not enough space below, place above
            if (top + ddRect.height > vh) {
                top = bRect.top - ddRect.height - 8;
            }

            // Clamp within viewport with small margin
            left = clamp(left, 8, Math.max(8, vw - ddRect.width - 8));
            top  = clamp(top, 8, Math.max(8, vh - ddRect.height - 8));

            dropdown.style.left = left + window.scrollX + 'px';
            dropdown.style.top  = top  + window.scrollY + 'px';
        }

        function showDropdown() {
            dropdown.style.display = 'block';
            positionDropdown();
            dropdown.setAttribute('aria-hidden','false');
            document.addEventListener('click', onDocClick, true);
            window.addEventListener('resize', positionDropdown, { passive:true });
            window.addEventListener('scroll', positionDropdown, { passive:true });
        }

        function hideDropdown() {
            dropdown.style.display = 'none';
            dropdown.setAttribute('aria-hidden','true');
            document.removeEventListener('click', onDocClick, true);
            window.removeEventListener('resize', positionDropdown);
            window.removeEventListener('scroll', positionDropdown);
        }

        function toggleDropdown(e){
            e && e.stopPropagation && e.stopPropagation();
            if (dropdown.style.display === 'block') hideDropdown();
            else showDropdown();
        }

        function onDocClick(e){
            const t = e.target;
            if (t && (t.closest('.Signup_Profile_Bubble') || t.closest('.Signup_Profile_Options_Dropdown') || t === toggleBtn)) return;
            hideDropdown();
        }

        // keep dropdown repositioned if bubble size/position changes
        if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => {
                if (dropdown.style.display === 'block') positionDropdown();
            });
            ro.observe(bubble);
        } else {
            // fallback: simple interval while visible
            let iv = null;
            const startWatch = () => {
                iv = setInterval(positionDropdown, 250);
            };
            const stopWatch = () => {
                if (iv) { clearInterval(iv); iv = null; }
            };
            const origShow = showDropdown;
            showDropdown = function(){ origShow(); startWatch(); };
            const origHide = hideDropdown;
            hideDropdown = function(){ stopWatch(); origHide(); };
        }

        // open on click/tap
        toggleBtn.addEventListener('click', toggleDropdown, { passive: true });

        // expose small API
        window.profileOptions = {
            show: showDropdown,
            hide: hideDropdown,
            toggle: toggleDropdown,
            position: positionDropdown
        };
    })();

    // close signup profile dropdown when clicking/tapping anywhere outside it
    (function(){
        function hideIfOpen(e){
            const dd = document.querySelector('.Signup_Profile_Options_Dropdown');
            if (!dd) return;
            if (dd.style.display !== 'block') return;

            // if click/tap is inside dropdown or the bubble/button that toggles it, do nothing
            if (e.target && (e.target.closest('.Signup_Profile_Options_Dropdown') || e.target.closest('.Signup_Profile_Bubble') || e.target.closest('#Signup_Profile_Options_Button'))) {
                return;
            }

            // prefer the exposed API if present
            try { if (window.profileOptions && typeof window.profileOptions.hide === 'function') { window.profileOptions.hide(); return; } } catch(e){}

            dd.style.display = 'none';
        }

        document.addEventListener('click', hideIfOpen, true);
        document.addEventListener('touchstart', hideIfOpen, { passive: true, capture: true });
    })();

    //Open profile dialog

    (function(){
        const openBtn = document.getElementById('Open_Signup_Upload_Profile_Dialog');
        const dialog = document.querySelector('.Signup_Upload_Profile_Dialog');
        if (!openBtn || !dialog) return;

        function centerAndShow(el){
            el.style.display = 'flex';
            el.style.position = 'absolute';
            // ensure layout measured before positioning
            const rect = el.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();
            el.style.left = Math.max(0, (bodyRect.width - rect.width) / 2) + 'px';
            el.style.top  = Math.max(0, (bodyRect.height - rect.height) / 2) + 'px';
            try { if (typeof bringToFront === 'function') bringToFront(el); } catch(e){}
        }

        openBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            centerAndShow(dialog);
            // focus first interactive element for accessibility
            try {
                const first = dialog.querySelector('button, input, [tabindex]');
                if (first && typeof first.focus === 'function') first.focus();
            } catch(e){}
        }, { passive: true });

        // wire close button if present
        const closeBtn = document.getElementById('Close_Signup_Upload_Profile_Dialog');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                dialog.style.display = 'none';
            });
        }
    })();

    (function(){
        const dialog = document.querySelector('.Signup_Upload_Profile_Dialog');
        const dropdown = document.querySelector('.Signup_Profile_Options_Dropdown');
        if (!dialog || !dropdown) return;

        function hideDropdown() {
            try {
                if (dropdown.style.display === 'block' || getComputedStyle(dropdown).display !== 'none') {
                    dropdown.style.display = 'none';
                    dropdown.setAttribute('aria-hidden', 'true');
                }
            } catch (e) {}
        }

        // Observe dialog visibility changes (inline style/class changes)
        const mo = new MutationObserver(() => {
            const isVisible = getComputedStyle(dialog).display !== 'none';
            if (isVisible) hideDropdown();
        });
        mo.observe(dialog, { attributes: true, attributeFilter: ['style', 'class', 'aria-hidden'] });

        // Also close dropdown when the dialog open button is used
        const openBtn = document.getElementById('Open_Signup_Upload_Profile_Dialog');
        if (openBtn) openBtn.addEventListener('click', hideDropdown, { passive: true });

        // Defensive: listen for custom shows (in case other code shows dialog)
        document.addEventListener('profileUploadDialogOpened', hideDropdown, { passive: true });
    })();

    //Get Profile Pic

    (function(){
        const btn = document.getElementById('Signup_Get_Picture_From_Computer');
        if (!btn) return;

        btn.addEventListener('click', (ev) => {
            // create a hidden file input on demand
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.style.display = 'none';
            document.body.appendChild(input);

            input.addEventListener('change', () => {
                const file = input.files && input.files[0];
                if (!file) {
                    input.remove();
                    return;
                }
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file.');
                    input.remove();
                    return;
                }

                const reader = new FileReader();
                reader.onload = () => {
                    const dataUrl = reader.result;

                    // dialog preview image
                    const dialogImg = document.querySelector('.Signup_Upload_Profile_Dialog img');
                    if (dialogImg) {
                        dialogImg.src = dataUrl;
                        dialogImg.alt = file.name || 'Profile picture';
                        dialogImg.dataset.selected = '1';
                    }

                    // signup bubble / profile button image
                    const bubbleBtnImg = document.getElementById('Signup_Profile_Options_Button') ||
                                         document.querySelector('.Signup_Profile_Bubble img');
                    if (bubbleBtnImg) {
                        bubbleBtnImg.src = dataUrl;
                        bubbleBtnImg.alt = file.name || 'Profile picture';
                        bubbleBtnImg.dataset.selected = '1';
                    }

                    // dispatch an event in case other code wants to react
                    try {
                        const evt = new CustomEvent('profilePictureChosen', { detail: { file, dataUrl } });
                        document.dispatchEvent(evt);
                    } catch (e) {}

                    input.remove();
                };

                reader.onerror = () => {
                    alert('Failed to read image file.');
                    input.remove();
                };

                reader.readAsDataURL(file);
            }, { once: true });

            // open file picker
            input.click();
        });
    })();

    (function(){
        // inject CSS rules to prevent profile / preview images from stretching
        const s = document.createElement('style');
        s.textContent = `
            /* make profile & preview images cover their container without distortion */
            .Signup_Profile_Bubble img,
            .Signup_Upload_Profile_Dialog img,
            .Verification_Window_Profile img,
            .Signup_Upload_Profile_Dialog_Profile_Pic img {
                width: 100% !important;
                height: 100% !important;
                object-fit: cover !important;
                object-position: center center !important;
                display: block !important;
            }
        `;
        document.head.appendChild(s);

        // helper to apply inline styles for any images added/changed at runtime
        function enforceNoStretch(sel) {
            document.querySelectorAll(sel).forEach(img => {
                try{
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.objectPosition = 'center';
                    img.style.display = 'block';
                }catch(e){}
            });
        }

        // apply immediately for existing elements
        ['.Signup_Profile_Bubble img',
         '.Signup_Upload_Profile_Dialog img',
         '.Verification_Window_Profile img',
         '.Signup_Upload_Profile_Dialog_Profile_Pic img'
        ].forEach(enforceNoStretch);

        // react when a new profile picture is chosen by the existing file-picker flow
        document.addEventListener('profilePictureChosen', () => {
            ['#Signup_Profile_Options_Button',
             '.Signup_Profile_Bubble img',
             '.Signup_Upload_Profile_Dialog img',
             '.Verification_Window_Profile img'
            ].forEach(enforceNoStretch);
        });

        // observe DOM changes and ensure any newly inserted profile images get the rule
        const mo = new MutationObserver((muts) => {
            muts.forEach(m => {
                if (m.addedNodes && m.addedNodes.length) {
                    m.addedNodes.forEach(n => {
                        if (n.nodeType === 1) {
                            if (n.matches && n.matches('img')) {
                                enforceNoStretch('img');
                            } else {
                                // check descendants
                                enforceNoStretch('.Signup_Profile_Bubble img');
                                enforceNoStretch('.Signup_Upload_Profile_Dialog img');
                                enforceNoStretch('.Verification_Window_Profile img');
                            }
                        }
                    });
                }
            });
        });
        mo.observe(document.body, { childList: true, subtree: true });
    })();

    //Set Profile Picture

    (function(){
        // robustly find the "Set Profile" button (handles malformed id in markup)
        let btn = document.getElementById('Signup_Set_Picture');
        if (!btn) {
            const dialog = document.querySelector('.Signup_Upload_Profile_Dialog');
            if (dialog) {
                btn = Array.from(dialog.querySelectorAll('button')).find(b => (b.id && b.id.startsWith('Signup_Set_Picture')) || b.textContent.trim().toLowerCase() === 'set profile');
            }
            if (!btn) btn = document.querySelector('button[id^="Signup_Set_Picture"]') || null;
        }
        if (!btn) return;

        btn.addEventListener('click', (ev) => {
            ev.preventDefault();
            const dialog = document.querySelector('.Signup_Upload_Profile_Dialog');
            if (!dialog) return;

            const dialogImg = dialog.querySelector('img');
            if (!dialogImg || !dialogImg.src) {
                // nothing to confirm, just close
                dialog.style.display = 'none';
                return;
            }

            // Apply confirmed image to signup bubble/button and verification profile where present
            const bubbleBtnImg = document.getElementById('Signup_Profile_Options_Button') || document.querySelector('.Signup_Profile_Bubble img');
            if (bubbleBtnImg) {
                bubbleBtnImg.src = dialogImg.src;
                bubbleBtnImg.alt = dialogImg.alt || 'Profile picture';
                bubbleBtnImg.dataset.selected = '1';
            }

            const verificationImg = document.querySelector('.Verification_Window_Profile img');
            if (verificationImg) {
                verificationImg.src = dialogImg.src;
                verificationImg.alt = dialogImg.alt || '';
                verificationImg.dataset.selected = '1';
            }

            // Ensure any other conventional selectors also get updated (defensive)
            document.querySelectorAll('.Signup_Profile_Bubble img, .Signup_Upload_Profile_Dialog img, #Signup_Profile_Options_Button, .Verification_Window_Profile img')
                .forEach(img => {
                    try {
                        if (img !== dialogImg && img.tagName === 'IMG') {
                            img.src = dialogImg.src;
                        }
                    } catch(e){}
                });

            // close the dialog
            dialog.style.display = 'none';

            // notify other code (reuse existing listener for profilePictureChosen and also emit a confirmed event)
            try { document.dispatchEvent(new CustomEvent('profilePictureChosen', { detail: { src: dialogImg.src } })); } catch(e){}
            try { document.dispatchEvent(new CustomEvent('profilePictureConfirmed', { detail: { src: dialogImg.src } })); } catch(e){}
        }, { passive: true });
    })();

    // Revert back to fullscreen if exit fullscreen.

    // Forgot Password.

    (function(){
        const openBtn = document.getElementById('Open_Forgot_Password');
        const dialog = document.querySelector('.Forgot_Password_Dialog');
        if (!openBtn || !dialog) return;

        function centerAndShow(el){
            el.style.display = 'flex';
            el.style.position = 'absolute';
            const rect = el.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();
            el.style.left = Math.max(0, (bodyRect.width - rect.width) / 2) + 'px';
            el.style.top  = Math.max(0, (bodyRect.height - rect.height) / 2) + 'px';
            try { if (typeof bringToFront === 'function') bringToFront(el); } catch(e){}
            const first = el.querySelector('input, button, [tabindex]');
            if (first && typeof first.focus === 'function') first.focus();
        }

        openBtn.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            centerAndShow(dialog);
        }, false);

        const closeBtn = document.getElementById('Close_Forgot_Password_Dialog');
        if (closeBtn) closeBtn.addEventListener('click', () => { dialog.style.display = 'none'; });
    })();

    (function(){
        const openBtn = document.getElementById('Open_Forgot_Password_Show_Password_Dialog');
        const dialog = document.querySelector('.Forgot_Password_Show_Password_Dialog');
        const closeBtn = document.getElementById('Close_Forgot_Password_Show_Password_Dialog');
        if (!openBtn || !dialog) return;

        function showDialog() {
            dialog.style.display = 'flex';
            dialog.style.position = 'fixed';
            dialog.style.left = '50%';
            dialog.style.top = '50%';
            dialog.style.transform = 'translate(-50%, -50%)';
            dialog.style.zIndex = '99999';
            try { if (typeof bringToFront === 'function') bringToFront(dialog); } catch (e) {}
            const focusTarget = dialog.querySelector('button, [tabindex], input');
            if (focusTarget && typeof focusTarget.focus === 'function') focusTarget.focus();
        }

        function hideDialog() {
            dialog.style.display = 'none';
        }

        openBtn.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            showDialog();
        }, false);

        if (closeBtn) {
            closeBtn.addEventListener('click', () => hideDialog(), false);
        }

        // close with Escape
        document.addEventListener('keydown', (ev) => {
            if (ev.key === 'Escape' && getComputedStyle(dialog).display !== 'none') hideDialog();
        });
    })();

    

    

   


    
</script>
