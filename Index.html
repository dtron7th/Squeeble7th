<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eden Economy</title>

    <link rel="stylesheet" href="CSS/UI.css">

</head>
<body>
    <style aria-label="Body_Style">
        body {
            background-color: rgb(0, 0, 0);
            width: 100dvw;
            height: 100dvh;
            display: flex;
            justify-content: center;
        }
    </style>

    <!-- ============================================================================ //
    // UNIVERSAL UI //
    // ============================================================================ -->

    <!--DOT GRID-->

    <div class="Dot_Grid">
        <style aria-label="Dot_Grid_Style">
        /* 10px x 10px dot grid background */
        .Dot_Grid {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;

            --dot-color: var(--Dot_Grid);
            --dot-size: 1px;
            --grid-spacing: 20px;

            background-image: radial-gradient(circle, var(--dot-color) var(--dot-size), transparent calc(var(--dot-size) + 0.5px));
            background-size: var(--grid-spacing) var(--grid-spacing);
        }
        </style>
    </div>

    
    <div class="Start" style="display: flex;">

        <style aria-label="Start_Body_Style">
            .Start {
                width: 100dvw;
                height: 100dvh;
                display: flex;
                justify-content: center;
                align-items: center;
            }

        </style>

        <!-- ============================================================================ //
        // START PROGRESS BAR //
        // ============================================================================ -->

        <div class="Start_Progress_Bar" style="display: none;">
            <div class="Start_Progress_Bar_Fill">

            </div>

            <style aria-label="Progress_Bar_Style">
                .Start_Progress_Bar {
                    position: absolute;
                    bottom: 10px;
                    width: calc(100% - 20px);
                    height: 20px;
                    border: 1px solid var(--Main_Border);
                }

                .Start_Progress_Bar > .Start_Progress_Bar_Fill {
                    width: 100%;
                    height: 100%;
                    background-color: var(--Progress_Bar_Background);
                    
                }
            </style>
        </div>

        <!-- ============================================================================ //
        // WALLPAPER //
        // ============================================================================ -->

        <div class="Wallpaper">
            <div class="Wallpaper_List">
                <img class="Wallpaper_Image" src="Images/Wallpaper/Wallpaper_1.jpg" alt="Wallpaper 1">
            </div>
            <div class="Glass">

            </div>

            <style aria-label="Start_Wallpaper_Style">
                .Wallpaper {
                    width: 100dvw;
                    height: 100dvh;
                    z-index: -1;
                }

                .Wallpaper_List {
                    width: 100dvw;
                    height: 100dvh;
                    
                }

                .Wallpaper_Image {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }

                .Glass {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100dvw;
                    height: 100dvh;
                    backdrop-filter: blur(10px);
                }
            </style>
            
            <script aria-label="Wallpaper_Slideshow">
                (() => {
                    const FADE_IN_MS = 800;
                    const BLEND_MODE = 'screen'; // try 'overlay', 'lighten', 'multiply', etc.

                    // inject fade-in keyframes/style
                    (function() {
                        const s = document.createElement('style');
                        s.textContent = `
                        @keyframes wallpaperFadeIn {
                            from { opacity: 0; }
                            to   { opacity: 1; }
                        }
                        .wallpaper-fade {
                            animation: wallpaperFadeIn ${FADE_IN_MS}ms ease both;
                        }`;
                        document.head.appendChild(s);
                    })();

                    // observe inline style opacity changes and apply fade class when an image becomes visible
                    (function() {
                        const observer = new MutationObserver(mutations => {
                            for (const m of mutations) {
                                const t = m.target;
                                if (!(t instanceof HTMLElement)) continue;
                                if (!t.classList.contains('Wallpaper_Image')) continue;
                                if (t.style && (t.style.opacity === '1' || t.style.opacity === '1.0')) {
                                    t.classList.add('wallpaper-fade');
                                    clearTimeout(t.___fadeRemoveTimer);
                                    t.___fadeRemoveTimer = setTimeout(() => {
                                        t.classList.remove('wallpaper-fade');
                                        delete t.___fadeRemoveTimer;
                                    }, FADE_IN_MS + 50);
                                }
                            }
                        });

                        observer.observe(document.body, { attributes: true, subtree: true, attributeFilter: ['style'] });
                        window.addEventListener('beforeunload', () => observer.disconnect());
                    })();

                    const container = document.querySelector('.Wallpaper_List');
                    if (!container) return;

                    const imgs = Array.from(container.querySelectorAll('img.Wallpaper_Image'));
                    if (!imgs.length) return;

                    // config (ms)
                    const displayDuration = 5000;      // time each image is fully visible
                    const transitionDuration = 1000;   // crossfade duration

                    // set container and image base styles
                    Object.assign(container.style, {
                        position: 'relative',
                        zIndex: '-1',
                        overflow: 'hidden',
                        isolation: 'isolate' // ensure blend modes compose within the container
                    });

                    imgs.forEach((img, i) => {
                        Object.assign(img.style, {
                            position: 'absolute',
                            inset: '0',
                            width: '100%',
                            height: '100%',
                            objectFit: 'cover',
                            transition: `opacity ${transitionDuration}ms ease`,
                            opacity: '0',
                            pointerEvents: 'none',
                            willChange: 'opacity, transform',
                            mixBlendMode: BLEND_MODE,
                            transform: 'translateZ(0)' // promote to its own layer for smoother compositing
                        });
                        img.dataset.wallIndex = i;
                    });

                    // Fisher-Yates shuffle
                    function shuffle(array) {
                        for (let i = array.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [array[i], array[j]] = [array[j], array[i]];
                        }
                        return array;
                    }

                    // build playback order (array of image elements)
                    let order = shuffle(imgs.slice());
                    let current = 0;
                    let timer = null;

                    // show a specific image element (crossfade from current to next)
                    function showIndex(nextIndex) {
                        const nextImg = order[nextIndex];
                        const curImg = order[current];

                        if (nextImg === curImg) {
                            nextImg.style.opacity = '1';
                            return;
                        }

                        // ensure next is on top visually by DOM order; move it to end if necessary
                        if (nextImg && nextImg.parentElement) nextImg.parentElement.appendChild(nextImg);

                        // bring next to visible (both visible for blend)
                        nextImg.style.opacity = '1';

                        // fade out previous after a tiny overlap to let blending occur
                        if (curImg) {
                            setTimeout(() => {
                                curImg.style.opacity = '0';
                            }, 10);
                        }

                        current = nextIndex;
                    }

                    // advance to next, reshuffle after a full loop
                    function advance() {
                        const next = (current + 1) % order.length;
                        showIndex(next);

                        // if we've completed a loop, reshuffle order but keep the currently visible image first
                        if (next === 0) {
                            const visible = order[current];
                            const remaining = imgs.filter(i => i !== visible);
                            shuffle(remaining);
                            order = [visible, ...remaining];
                            current = 0;
                        }
                    }

                    // preload images and start slideshow
                    Promise.all(order.map(img => {
                        if (img.complete) return Promise.resolve();
                        return new Promise(res => { img.onload = img.onerror = res; });
                    })).then(() => {
                        // ensure all start hidden, then reveal first without flash
                        order.forEach(img => img.style.opacity = '0');
                        order[0].style.opacity = '1';
                        current = 0;

                        // start interval
                        timer = setInterval(advance, displayDuration);
                    });

                    // cleanup
                    window.addEventListener('beforeunload', () => {
                        if (timer) clearInterval(timer);
                    });
                })();
            </script>
        </div>

        <!-- ============================================================================ //
        // TOP UI //
        // ============================================================================ -->

        <div class="Top_UI">
            <div class="Details">
                <div class="Clock">
                    <p class="Clock_HMSM">12:00:00 PM</p>
                    <p class="Clock_DMY">DD/MM/YYYY</p>
                </div>
                <div class="Device_Location">
                    <p class="Device_Location_Point">Location</p>
                </div>
                <div class="Network_Name">
                    <p class="Current_Network_Name">Network Name</p>
                </div>
            </div>
            <div class="User_Information">
                <button id="About">[About]</button>
                <button id="About">[Road Map]</button>
                <button id="About">[Character Sheet]</button>
                <button id="About">[Version]</button>
                <button id="About">[Share]</button>
            </div>

            <style aria-label="Top_UI_Style">
                .Top_UI {
                    position: absolute;
                    top: 10px;
                    width: 100%;
                }

                .Top_UI > .Details {
                    position: absolute;
                    right: 10px;

                }

                .Top_UI > .Details > .Clock > .Clock_HMSM {
                    color: var(--Main_Text_Color_1);

                }

                .Top_UI > .Details > .Clock > .Clock_DMY {
                    color: var(--Main_Text_Color_1);
                }

                .Top_UI > .Details > .Device_Location {
                    position: absolute;
                    top: 60px;
                    color: var(--Main_Text_Color_1);

                }

                .Top_UI > .Details > .Network_Name {
                    position: absolute;
                    top: 110px;
                    color: var(--Main_Text_Color_1);
                }

                .Top_UI > .User_Information {
                    position: absolute;
                    left: 10px;
                    color: var(--Main_Text_Color_1);
                    display: flex;
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 10px;
                }
                
            </style>

            <script aria-label="Top_UI_Script">

                /* ============================================================================ */
                /* SET CLOCK */
                /* ============================================================================ */
                (() => {
                    const el = document.querySelector('.Clock_HMSM');
                    if (!el) return;

                    el.style.fontSize = '14px';

                    const pad = (n, d = 2) => String(n).padStart(d, '0');

                    function update() {
                        const now = new Date();
                        let h = now.getHours();
                        const ampm = h >= 12 ? 'PM' : 'AM';
                        h = h % 12 || 12;
                        const m = pad(now.getMinutes());
                        const s = pad(now.getSeconds());
                        const ms = String(now.getMilliseconds()).padStart(3, '0');
                        el.textContent = `${pad(h)}:${m}:${s}.${ms} ${ampm}`;
                        requestAnimationFrame(update);
                    }

                    requestAnimationFrame(update);
                })();

                /* ============================================================================ */
                /* SET DATE */
                /* ============================================================================ */

                (() => {
                    const el = document.querySelector('.Clock_DMY');
                    if (!el) return;

                    el.style.fontSize = '10px';

                    const pad = (n, d = 2) => String(n).padStart(d, '0');

                    function update() {
                        const now = new Date();
                        const d = pad(now.getDate());
                        const m = pad(now.getMonth() + 1);
                        const y = now.getFullYear();
                        el.textContent = `${d}/${m}/${y}`;
                    }

                    update();
                })();

                /* ============================================================================ */
                /* GET DEVICE LOCATION */
                /* ============================================================================ */

                (async () => {
                    const el = document.querySelector('.Device_Location_Point');
                    if (!el || !navigator.geolocation) return;
                    el.style.fontSize = '10px';
                    el.textContent = '[Locating...]';

                    const US_STATES = {
                        "alabama":"AL","alaska":"AK","arizona":"AZ","arkansas":"AR","california":"CA","colorado":"CO",
                        "connecticut":"CT","delaware":"DE","florida":"FL","georgia":"GA","hawaii":"HI","idaho":"ID",
                        "illinois":"IL","indiana":"IN","iowa":"IA","kansas":"KS","kentucky":"KY","louisiana":"LA",
                        "maine":"ME","maryland":"MD","massachusetts":"MA","michigan":"MI","minnesota":"MN","mississippi":"MS",
                        "missouri":"MO","montana":"MT","nebraska":"NE","nevada":"NV","new hampshire":"NH","new jersey":"NJ",
                        "new mexico":"NM","new york":"NY","north carolina":"NC","north dakota":"ND","ohio":"OH","oklahoma":"OK",
                        "oregon":"OR","pennsylvania":"PA","rhode island":"RI","south carolina":"SC","south dakota":"SD",
                        "tennessee":"TN","texas":"TX","utah":"UT","vermont":"VT","virginia":"VA","washington":"WA",
                        "west virginia":"WV","wisconsin":"WI","wyoming":"WY","district of columbia":"DC"
                    };

                    function formatLocation(city, region, country) {
                        // final format: (City Name, AA, Country)
                        if (!city) city = '';
                        if (!region) region = '';
                        if (!country) country = '';
                        return `(${city.trim() || 'Unknown'}, ${region.trim() || '??'}, ${country.trim() || 'Unknown'})`;
                    }

                    navigator.geolocation.getCurrentPosition(async pos => {
                        try {
                            const lat = pos.coords.latitude;
                            const lon = pos.coords.longitude;
                            const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&addressdetails=1`;
                            const resp = await fetch(url, { headers: { 'Accept-Language': 'en' } });
                            if (!resp.ok) throw new Error('geocode failed');
                            const data = await resp.json();
                            const a = data.address || {};

                            const city = a.city || a.town || a.village || a.municipality || a.hamlet || a.county || '';
                            const country = a.country || '';
                            const cc = (a.country_code || '').toUpperCase();

                            let region = '';
                            if (a.state_code) region = a.state_code.toUpperCase();
                            else if (a.state) {
                                const s = a.state.toLowerCase();
                                if (cc === 'US' && US_STATES[s]) region = US_STATES[s];
                                else region = a.state; // fallback to full state name
                            } else if (a.region) region = a.region;
                            else if (a.county) region = a.county;

                            el.style.fontSize = '10px';
                            el.textContent = formatLocation(city, region, country);
                        } catch (e) {
                            el.style.fontSize = '10px';
                            el.textContent = 'Location unavailable';
                            console.error(e);
                        }
                    }, err => {
                        el.style.fontSize = '10px';
                        el.textContent = 'Permission denied or unavailable';
                        console.warn(err);
                    }, { enableHighAccuracy: false, maximumAge: 60_000, timeout: 10_000 });
                })();

                /* ============================================================================ */
                /* GET NETWORK NAME */
                /* ============================================================================ */

                (async () => {
                    const el = document.querySelector('.Current_Network_Name');
                    if (!el) return;
                    el.style.fontSize = '10px';
                    el.textContent = '[Network Unavailable]';

                    try {
                        const resp = await fetch('https://api.ipify.org?format=json');
                        if (!resp.ok) throw new Error('network fetch failed');
                        const data = await resp.json();
                        const ip = data.ip || '';

                        // Simple hash to generate a pseudo network name from IP
                        let hash = 0;
                        for (let i = 0; i < ip.length; i++) {
                            hash = ((hash << 5) - hash) + ip.charCodeAt(i);
                            hash |= 0; // Convert to 32bit integer
                        }
                        const networkName = 'Net-' + Math.abs(hash).toString(36).toUpperCase().slice(0, 6);

                        el.style.fontSize = '10px';
                        el.textContent = networkName;
                    } catch (e) {
                        el.style.fontSize = '10px';
                        el.textContent = '[Network Unavailable]';
                        console.error(e);
                    }
                })();
            </script>
        </div>

        <!-- ============================================================================ //
        // START WINDOW //
        // ============================================================================ -->

        <div class="Window Start_Window" style="width:280px; height:220px;">
            <div class="Window_Header">
                <p class="Title">Start</p>
                <button class="Close_Button"></button>
            </div>
            <div class="Content">
                <div class="Paragraph">
                    <p>Welcome to Eden Economy! Please select your platform to continue.</p>
                </div>
                <div class="Start_Navigator">
                    <button class="Start_Navigator_Button" id="Start_Using_Desktop_System">[Desktop]</button>
                    <button class="Start_Navigator_Button" id="Start_Using_Phone_System">[Phone]</button>
                </div>
            </div>

            <style aria-label="Start_Window_Style">
                .Start_Window {
                    position: absolute;

                }

                .Start_Window > .Content > .Paragraph {
                    position: absolute;
                    top: 40px;
                    color: var(--Main_Text_Color_1);
                    font-size: var(--Main_Text_2);
                    text-align: center;
                    width: 240px;
                }

                .Start_Window > .Content > .Start_Navigator {
                    position: absolute;
                    bottom: 20px;
                    width: 100%;
                    display: flex;
                    flex-direction: row;
                    gap: 20px;
                    justify-content: center;
                }

                .Start_Window > .Content > .Start_Navigator > .Start_Navigator_Button {
                    font-size: var(--Main_Text_2);
                }

            </style>

            <script aria-label="Start_Window_Script">
                
            </script>
        </div>

        <!-- ============================================================================ //
        // SUB WINDOWS //
        // ============================================================================ -->

        <div class="Sub_Windows">
           
        </div>
    </div>

    <div class="Boot_Sequense" style="display: none;">

        <style aria-label="Boot_Sequense_Body_Style">
            .Boot_Sequense {
                position: absolute;
                top: 0;
                left: 0;
                width: 100dvw;
                height: 100dvh;
                display: flex;
                justify-content: center;
            }
        </style>

         <!-- ============================================================================ //
        // BOOT SEQUENSE PROGRESS BAR //
        // ============================================================================ -->

        <div class="Boot_Sequense_Progress_Bar">
            <div class="Boot_Sequense_Progress_Bar_Fill">

            </div>

            <style aria-label="Boot_Sequense_Progress_Bar_Style">
                .Boot_Sequense_Progress_Bar {
                    position: absolute;
                    bottom: 10px;
                    width: calc(100% - 20px);
                    height: 20px;
                    border: 1px solid var(--Main_Border);
                }

                .Boot_Sequense_Progress_Bar > .Boot_Sequense_Progress_Bar_Fill {
                    width: 100%;
                    height: 100%;
                    background-color: var(--Progress_Bar_Background);
                    
                }
            </style>
        </div>

        <div class="Boot_Wallpaper">
            <img class="Boot_Wallpaper_Image" src="Images/Wallpaper/Wallpaper_1.jpg" alt="Wallpaper 1">
            <div class="Boot_Glass">

            </div>

            <style aria-label="Boot_Wallpaper_Style">
                .Boot_Wallpaper {
                    position: fixed;
                    width: 100dvw;
                    height: 100dvh;
                    z-index: -1;
                }

                .Boot_Wallpaper_Image {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }

                .Boot_Glass {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100dvw;
                    height: 100dvh;
                    backdrop-filter: blur(10px);
                }

            </style>
        </div>

        <div class="Boot_Sequense_Space">
            <p class="Boot_Sequense_Copy_Right">Eden Economy Web-World Market 2026 &#169</p>
            <br>
            <p class="Boot_Sequense_Start_String" style="display: none;">Starting Eden Economy...</p>
            <br>
            <br>
            <p class="Boot_Sequense_MIT_License" style="display: none;">MIT License

                Copyright (c) 2026 dtron7th Corporation
                <br>
                <br>

                Permission is hereby granted, free of charge, to any person obtaining a copy
                of this software and associated documentation files (the "Software"), to deal
                in the Software without restriction, including without limitation the rights
                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                copies of the Software, and to permit persons to whom the Software is
                furnished to do so, subject to the following conditions:
                <br>
                <br>
                The above copyright notice and this permission notice shall be included in all
                copies or substantial portions of the Software.
                <br>
                <br>
                THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                SOFTWARE.
            </p>
            <br>
            <br>
            <p class="Site_Language" style="display: none;">Site Language = [HTML 5, CSS 3, JAVASCRIPT, PHP, MYSQL]</p>
            <br>
            <p class="Main_IDE_Editor" style="display: none;">Use Visual Studio Code V: 1.96.2 or higher</p>
            <br>
            <br>
            <p class="Seperator_1" style="display: none;">
            //###################################################
            <br>
            //###################################################
            </p>
            <br>
            <br>
            <p class="Detect_Device_Information" style="display: none; width: 400px;"></p>
            <br>
            <br>
            <p class="Get_Network_Information" style="display: none; width: 400px;"></p>
            <br>
            <br>
            <p class="Is_Connected" style="display: none; width: 400px"></p>
            <br>
            <br>
            <p class="Check_Database" style="display: none; width: 400px"></p>
            <br>
            <br>
            <p class="Continue_To_Login" style="display: none; width: 400px">Finish</p>
                
            <style aria-label="Boot_Sequense_Style">

                .Boot_Sequense > .Boot_Sequense_Space {
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    text-align: left;
                    color: var(--Main_Text_Color_1);
                    font-size: var(--Main_Text_1);
                }

                .Boot_Sequense > .Boot_Sequense_Space > .Boot_Sequense_Copy_Right {
                    color: var(--Main_Text_Color_1);
                    font-size: var(--Main_Text_3);
                }

                .Boot_Sequense > .Boot_Sequense_Space > .Boot_Sequense_MIT_License {
                    width: 300px;
                }

                .Boot_Sequense > .Boot_Sequense_Space > .Continue_To_Login {
                    padding-bottom: 200px;
                }

            </style>
            
            <script aria-label="Boot_Sequense_Script">

                /* ============================================================================ */
                /* OPEN BOOT SEQUENCE */
                /* ============================================================================ */

    

                (() => {
                    const btn = document.getElementById('Start_Using_Phone_System');
                    const progress = document.querySelector('.Start_Progress_Bar');
                    const fill = progress ? progress.querySelector('.Start_Progress_Bar_Fill') : null;
                    const boot = document.getElementById('Boot_Sequense') || document.querySelector('.Boot_Sequense');
                    const start = document.querySelector('.Start');

                    if (!btn) return;

                    btn.addEventListener('click', () => {
                        btn.disabled = true;
                        if (progress) progress.style.display = 'block';

                        const DURATION = 1000;
                        const PCTS = [20, 70, 100];
                        // times: spread events over the duration (you can tweak factors if desired)
                        const TIMES = PCTS.map((_, i, a) => Math.round(((i + 1) / a.length) * DURATION));

                        if (fill) {
                            fill.style.transition = 'none';
                            fill.style.width = '0%';
                            void fill.offsetWidth;

                            PCTS.forEach((pct, i) => {
                                setTimeout(() => {
                                    fill.style.width = pct + '%';
                                }, TIMES[i]);
                            });

                            // Ensure final state at DURATION
                            setTimeout(() => {
                                fill.style.width = '100%';
                            }, DURATION);
                        }

                        setTimeout(() => {
                            document.querySelectorAll('.Dot_Grid').forEach(el => el.remove());
                            if (progress) progress.style.display = 'none';
                            if (start) start.style.display = 'none';
                            if (boot) boot.style.display = 'flex';
                        }, DURATION);
                    });
                })();

                (() => {
                    const boot = document.getElementById('Boot_Sequense') || document.querySelector('.Boot_Sequense');
                    if (!boot) return;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    async function enterFullscreen() {
                        const el = document.documentElement; // use whole page
                        if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) return;
                        try {
                            if (el.requestFullscreen) await el.requestFullscreen();
                            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                            else if (el.msRequestFullscreen) el.msRequestFullscreen();
                        } catch (e) {
                            console.warn('Fullscreen request failed:', e);
                        }
                    }

                    async function exitFullscreen() {
                        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) return;
                        try {
                            if (document.exitFullscreen) await document.exitFullscreen();
                            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                            else if (document.msExitFullscreen) document.msExitFullscreen();
                        } catch (e) {
                            console.warn('Exit fullscreen failed:', e);
                        }
                    }

                    // Observe style/class changes to detect when boot becomes visible/hidden
                    const mo = new MutationObserver(() => {
                        if (isDisplayed(boot)) enterFullscreen();
                        else exitFullscreen();
                    });
                    mo.observe(boot, { attributes: true, attributeFilter: ['style', 'class'] });

                    // initial check
                    if (isDisplayed(boot)) enterFullscreen();

                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                

                /* ============================================================================ */
                /* RUN BOOT SEQUENCE */
                /* ============================================================================ */

                //STARTING EDEN ECONOMY BOOT SEQUENCE

                (() => {
                    const boot = document.getElementById('Boot_Sequense') || document.querySelector('.Boot_Sequense');
                    const el = document.querySelector('.Boot_Sequense_Start_String');
                    if (!boot || !el) return;

                    let triggered = false;
                    function triggerShow() {
                        if (triggered) return;
                        triggered = true;
                        setTimeout(() => el.style.display = 'block', 3000);
                    }

                    // If boot is already visible, start timer immediately
                    if (getComputedStyle(boot).display !== 'none') {
                        triggerShow();
                    }

                    // Observe style/display changes on the boot container
                    const mo = new MutationObserver(() => {
                        if (getComputedStyle(boot).display !== 'none') triggerShow();
                    });
                    mo.observe(boot, { attributes: true, attributeFilter: ['style'] });

                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                (() => {
                    const el = document.querySelector('.Boot_Sequense_Start_String');
                    if (!el) return;
                    const base = 'Starting Eden Economy';
                    el.style.whiteSpace = 'pre';
                    el.innerHTML = base + ' <span class="boot-dots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';

                    const dots = Array.from(el.querySelectorAll('.boot-dots .dot'));
                    dots.forEach(d => {
                        d.style.opacity = '0';
                        d.style.transition = 'none';
                        d.style.display = 'inline-block';
                        d.style.margin = '0 2px';
                    });

                    const seq = [
                        [1, 0, 0],
                        [1, 1, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ];

                    let s = 0;
                    const interval = 400;
                    let id = null;
                    const INITIAL_HIDE_MS = 4000;
                    let startTimeoutId = null;

                    function step() {
                        const state = seq[s];
                        dots.forEach((d, i) => d.style.opacity = state[i] ? '1' : '0');
                        s = (s + 1) % seq.length;
                    }

                    function startBlinking() {
                        if (id) return;
                        // ensure starting state
                        s = 0;
                        step();
                        id = setInterval(step, interval);
                    }

                    function stopBlinking() {
                        if (!id) return;
                        clearInterval(id);
                        id = null;
                        dots.forEach(d => d.style.opacity = '0');
                    }

                    function cancelPendingStart() {
                        if (startTimeoutId) {
                            clearTimeout(startTimeoutId);
                            startTimeoutId = null;
                        }
                    }

                    function startWithInitialHide() {
                        // hide dots immediately, then start animation after short delay
                        dots.forEach(d => d.style.opacity = '0');
                        cancelPendingStart();
                        startTimeoutId = setTimeout(() => {
                            startBlinking();
                            startTimeoutId = null;
                        }, INITIAL_HIDE_MS);
                    }

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    // start with initial hide if already visible
                    if (isDisplayed(el)) startWithInitialHide();

                    // observe display/style changes on the element and start/stop accordingly
                    const mo = new MutationObserver(() => {
                        if (isDisplayed(el)) startWithInitialHide();
                        else {
                            cancelPendingStart();
                            stopBlinking();
                        }
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => {
                        cancelPendingStart();
                        stopBlinking();
                        mo.disconnect();
                    });
                })();

                // RUN EDEN ECONOMY CORPORATION OPEN SOURCE LEICENSE

                (() => {
                    const startEl = document.querySelector('.Boot_Sequense_Start_String');
                    const licEl = document.querySelector('.Boot_Sequense_MIT_License');
                    if (!startEl || !licEl) return;

                    // inject rule to forcibly hide dots when license is shown
                    const STYLE_ID = 'boot-seq-stop-blink-style';
                    if (!document.getElementById(STYLE_ID)) {
                        const s = document.createElement('style');
                        s.id = STYLE_ID;
                        s.textContent = `
                            .Boot_Sequense_Start_String.stop-blink .boot-dots .dot {
                                opacity: 0 !important;
                                transition: none !important;
                            }`;
                        document.head.appendChild(s);
                    }

                    let showTimerId = null;        // delays showing the license block
                    let revealTimerId = null;      // interval between revealing sections
                    let currentSection = 0;
                    let mo = null;
                    let shownOnce = false;         // prevent repeating the cycle
                    const DELAY_MS = 12000;        // original delay before license appears
                    const SECTION_DELAY_MS = 1000; // 1s between sections

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    // Prepare sections: split original HTML into chunks by two-or-more <br> or blank lines.
                    const rawHtml = licEl.innerHTML.trim();
                    // Split on two or more <br> (with optional whitespace) or double newlines
                    const parts = rawHtml.split(/(?:<(?:br|BR)\s*\/?>\s*){2,}|\n{2,}/).map(s => s.trim()).filter(Boolean);

                    // Build section elements (hidden by default)
                    licEl.innerHTML = '';
                    const sectionEls = parts.map((part, i) => {
                        const d = document.createElement('div');
                        d.className = 'mit-section';
                        d.style.display = 'none';
                        d.style.marginBottom = '0.5rem';
                        d.innerHTML = part;
                        licEl.appendChild(d);
                        return d;
                    });

                    function resetSections() {
                        if (revealTimerId) {
                            clearInterval(revealTimerId);
                            revealTimerId = null;
                        }
                        currentSection = 0;
                        sectionEls.forEach(s => s.style.display = 'none');
                    }

                    function revealSectionsOnce() {
                        if (!sectionEls.length) return;
                        resetSections();
                        // show first immediately
                        sectionEls[0].style.display = 'block';
                        currentSection = 1;
                        if (sectionEls.length > 1) {
                            revealTimerId = setInterval(() => {
                                if (currentSection >= sectionEls.length) {
                                    clearInterval(revealTimerId);
                                    revealTimerId = null;
                                    return;
                                }
                                sectionEls[currentSection].style.display = 'block';
                                currentSection++;
                            }, SECTION_DELAY_MS);
                        }
                    }

                    function scheduleShow() {
                        if (showTimerId || shownOnce) return;
                        showTimerId = setTimeout(() => {
                            licEl.style.display = 'block';
                            // stop the visible blinking by adding class that forces dots hidden
                            startEl.classList.add('stop-blink');
                            // reveal license text one section at a time
                            revealSectionsOnce();
                            showTimerId = null;
                            shownOnce = true;
                            // once shown, stop observing/handling further visibility changes
                            if (mo) {
                                mo.disconnect();
                                mo = null;
                            }
                        }, DELAY_MS);
                    }

                    function cancelAndHide() {
                        // if we've already shown once, never hide or reschedule
                        if (shownOnce) return;
                        if (showTimerId) {
                            clearTimeout(showTimerId);
                            showTimerId = null;
                        }
                        if (revealTimerId) {
                            clearInterval(revealTimerId);
                            revealTimerId = null;
                        }
                        licEl.style.display = 'none';
                        startEl.classList.remove('stop-blink');
                        resetSections();
                    }

                    // Ensure license is hidden initially
                    licEl.style.display = 'none';
                    startEl.classList.remove('stop-blink');
                    resetSections();

                    // If start is already visible, schedule immediately
                    if (isDisplayed(startEl)) scheduleShow();

                    // Observe visibility changes on the start element
                    mo = new MutationObserver(() => {
                        if (shownOnce) {
                            if (mo) { mo.disconnect(); mo = null; }
                            return;
                        }
                        if (isDisplayed(startEl)) scheduleShow();
                        else cancelAndHide();
                    });
                    mo.observe(startEl, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => {
                        if (showTimerId) clearTimeout(showTimerId);
                        if (revealTimerId) clearInterval(revealTimerId);
                        if (mo) mo.disconnect();
                    });
                })();

                //RUN SITE LANGUAGE

                (() => {
                    const lic = document.querySelector('.Boot_Sequense_MIT_License');
                    const lang = document.querySelector('.Site_Language');
                    if (!lic || !lang) return;

                    lang.style.display = 'none';
                    let timer = null;
                    let shown = false;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (shown || timer) return;
                        timer = setTimeout(() => {
                            lang.style.display = 'block';
                            shown = true;
                            timer = null;
                        }, 6000);
                    }

                    function cancelShow() {
                        if (timer) {
                            clearTimeout(timer);
                            timer = null;
                        }
                        if (!shown) lang.style.display = 'none';
                    }

                    if (isDisplayed(lic)) scheduleShow();

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(lic)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(lic, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => {
                        if (timer) clearTimeout(timer);
                        mo.disconnect();
                    });
                })();

                //RUN MAIN_IDE_EDITOR

                (() => {
                    const lang = document.querySelector('.Site_Language');
                    const ide = document.querySelector('.Main_IDE_Editor');
                    if (!lang || !ide) return;

                    ide.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            ide.style.display = 'block';
                            timerId = null;
                        }, 1000);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(lang)) ide.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(lang)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(lang, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(lang)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                //RUN SEPERATOR_1

                (() => {
                    const lang = document.querySelector('.Main_IDE_Editor');
                    const sep = document.querySelector('.Seperator_1');
                    if (!lang || !sep) return;

                    sep.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            sep.style.display = 'block';
                            timerId = null;
                        }, 100);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(lang)) sep.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(lang)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(lang, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(lang)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                //DETECT_DEVICE_INFORMATION

                (() => {
                    const sep = document.querySelector('.Seperator_1');
                    const det = document.querySelector('.Detect_Device_Information');
                    if (!sep || !det) return;

                    det.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            det.style.display = 'block';
                            timerId = null;
                        }, 6000);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(sep)) det.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(sep)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(sep, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(sep)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                (() => {
                    const el = document.querySelector('.Detect_Device_Information');
                    if (!el) return;

                    function detectDevice() {
                        const ua = navigator.userAgent || '';
                        const uaData = navigator.userAgentData || null;
                        const platform = navigator.platform || (uaData && uaData.platform) || 'Unknown';
                        const maxTouch = navigator.maxTouchPoints || 0;
                        const hasTouch = maxTouch > 0 || 'ontouchstart' in window;
                        const cores = navigator.hardwareConcurrency || 'unknown';
                        const memory = navigator.deviceMemory || 'unknown';
                        const resolution = `${screen.width}${screen.height} @${window.devicePixelRatio || 1}x`;

                        // Determine broad device class
                        let deviceClass = 'Unknown';
                        if (/SmartTV|SMART-TV|TV|HbbTV|AppleTV|GoogleTV|BRAVIA|Roku|NetCast/i.test(ua)) deviceClass = 'TV';
                        else if (/Xbox|PlayStation|Nintendo/i.test(ua)) deviceClass = 'Console';
                        else {
                            const isMobileUA = uaData?.mobile ?? /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(ua);
                            const isTabletUA = /Tablet|iPad|Nexus 7|Kindle|SM-T|Tab/i.test(ua);
                            // heuristics: explicit tablet UA OR touch + large shortest-side
                            const shortestSide = Math.min(screen.width, screen.height);
                            if (isTabletUA || (hasTouch && shortestSide >= 600 && !/Mobi/i.test(ua))) deviceClass = 'Tablet';
                            else if (isMobileUA || hasTouch) deviceClass = 'Phone';
                            else deviceClass = 'Desktop/Laptop';
                        }

                        const brands = uaData?.brands ? uaData.brands.map(b => b.brand).join(', ') : null;
                        const agentInfo = brands || ua;

                        el.textContent = [
                            `Device: ${deviceClass}`,
                            `Platform: ${platform}`,
                            `Cores: ${cores}`,
                            `Memory(GB): ${memory}`,
                            `Touch Support: ${hasTouch ? 'Yes (' + maxTouch + ')' : 'No'}`,
                            `Resolution: ${resolution}`,
                            `UserAgent: ${agentInfo}`
                        ].join(' | ');
                    }

                    // run immediately and whenever element becomes visible
                    detectDevice();
                    const mo = new MutationObserver(() => {
                        if (getComputedStyle(el).display !== 'none') detectDevice();
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });
                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                //GET_NETWORK_INFORMATION

                (() => {
                    const det = document.querySelector('.Detect_Device_Information');
                    const net = document.querySelector('.Get_Network_Information');
                    if (!det || !net) return;

                    net.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            net.style.display = 'block';
                            timerId = null;
                        }, 2000);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(det)) net.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(det)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(det, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(det)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                (() => {
                    const el = document.querySelector('.Get_Network_Information');
                    if (!el) return;
                    el.textContent = 'Detecting network...';

                    const timeoutFetch = (url, ms = 5000) => {
                        const ac = new AbortController();
                        const id = setTimeout(() => ac.abort(), ms);
                        return fetch(url, { signal: ac.signal }).finally(() => clearTimeout(id));
                    };

                    async function getPublicIP() {
                        try {
                            const res = await timeoutFetch('https://api.ipify.org?format=json', 5000);
                            if (!res.ok) return null;
                            const j = await res.json();
                            return j.ip || null;
                        } catch {
                            return null;
                        }
                    }

                    async function getIPDetails(ip) {
                        if (!ip) return null;
                        try {
                            const res = await timeoutFetch(`https://ipapi.co/${ip}/json/`, 5000);
                            if (!res.ok) return null;
                            return await res.json();
                        } catch {
                            return null;
                        }
                    }

                    function getConnectionInfo() {
                        const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
                        if (!c) return null;
                        return {
                            effectiveType: c.effectiveType,
                            downlink: c.downlink,
                            rtt: c.rtt,
                            saveData: !!c.saveData
                        };
                    }

                    async function measureLatency(url = 'https://api.ipify.org?format=json') {
                        try {
                            const t0 = performance.now();
                            const res = await timeoutFetch(url, 5000);
                            if (!res) return null;
                            // consume body to ensure request completes (some endpoints respond empty with no-cors)
                            await res.text().catch(() => {});
                            const t1 = performance.now();
                            return Math.round(t1 - t0);
                        } catch {
                            return null;
                        }
                    }

                    function getLocalIPs() {
                        return new Promise((resolve) => {
                            const ips = new Set();
                            try {
                                const pc = new RTCPeerConnection({ iceServers: [] });
                                // create dummy data channel to trigger ICE
                                try { pc.createDataChannel('d'); } catch (e) {}
                                pc.onicecandidate = (evt) => {
                                    if (!evt.candidate) {
                                        try { pc.close(); } catch {}
                                        resolve(Array.from(ips));
                                        return;
                                    }
                                    const cand = evt.candidate.candidate || '';
                                    const re = /([0-9]{1,3}(?:\.[0-9]{1,3}){3})/g;
                                    let m;
                                    while ((m = re.exec(cand))) ips.add(m[1]);
                                };
                                pc.createOffer()
                                .then(offer => pc.setLocalDescription(offer))
                                .catch(() => {
                                    try { pc.close(); } catch {}
                                    resolve([]);
                                });
                                // safety timeout
                                setTimeout(() => {
                                    try { pc.close(); } catch {}
                                    resolve(Array.from(ips));
                                }, 3000);
                            } catch {
                                resolve([]);
                            }
                        });
                    }

                    (async () => {
                        const [pubIP, latency, localIPs] = await Promise.all([
                            getPublicIP(),
                            measureLatency(),
                            getLocalIPs()
                        ]);

                        const details = await getIPDetails(pubIP);
                        const conn = getConnectionInfo();

                        const parts = [];
                        if (pubIP) parts.push(`Public IP: ${pubIP}`);
                        if (details) {
                            if (details.org) parts.push(`ISP: ${details.org}`);
                            if (details.city || details.region || details.country_name) {
                                const city = details.city || '';
                                const region = details.region || '';
                                const country = details.country_name || '';
                                parts.push(`Location: ${[city, region, country].filter(Boolean).join(', ')}`);
                            }
                        }
                        if (latency != null) parts.push(`Latency: ${latency} ms`);
                        if (conn) parts.push(`Conn: ${conn.effectiveType || 'unknown'} (${conn.downlink ? conn.downlink + 'Mb/s' : 'n/a'}, rtt ${conn.rtt || 'n/a'}ms)`);
                        if (localIPs && localIPs.length) parts.push(`Local IPs: ${localIPs.join(', ')}`);
                        if (!parts.length) el.textContent = 'Network information unavailable';
                        else el.textContent = parts.join(' | ');
                    })();
                })();

                //IS_CONNECTED

                (() => {
                    const net = document.querySelector('.Get_Network_Information');
                    const con = document.querySelector('.Is_Connected');
                    if (!net || !con) return;

                    con.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            con.style.display = 'block';
                            timerId = null;
                        }, 4000);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(net)) con.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(net)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(net, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(net)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                (() => {
                    const el = document.querySelector('.Is_Connected');
                    if (!el) return;

                    const timeoutFetch = (url, ms = 3000) => {
                        const ac = new AbortController();
                        const id = setTimeout(() => ac.abort(), ms);
                        return fetch(url, { signal: ac.signal }).finally(() => clearTimeout(id));
                    };

                    let last = '';

                    async function checkNetwork() {
                        // quick offline hint
                        if (!navigator.onLine) {
                            update('Offline');
                            return;
                        }

                        try {
                            const t0 = performance.now();
                            const res = await timeoutFetch('https://api.ipify.org?format=json', 3000);
                            const t1 = performance.now();
                            if (!res || !res.ok) throw new Error('no-response');

                            const json = await res.json().catch(() => null);
                            const ip = json && json.ip ? json.ip : 'unknown';
                            const latency = Math.max(0, Math.round(t1 - t0));
                            update(`Online | Public IP: ${ip} | Latency: ${latency} ms`);
                        } catch (e) {
                            // fallback to navigator.onLine if fetch fails
                            update(navigator.onLine ? 'Online (limited)' : 'Offline');
                        }
                    }

                    function update(text) {
                        if (text === last) return;
                        last = text;
                        el.textContent = text;
                    }

                    // respond to browser events
                    window.addEventListener('online', checkNetwork);
                    window.addEventListener('offline', checkNetwork);

                    // periodic checks while visible
                    const intervalId = setInterval(checkNetwork, 15000);

                    // initial check
                    checkNetwork();

                    // cleanup
                    window.addEventListener('beforeunload', () => {
                        clearInterval(intervalId);
                        window.removeEventListener('online', checkNetwork);
                        window.removeEventListener('offline', checkNetwork);
                    });
                })();

                //CHECK_DATABASE

                (() => {
                    const con = document.querySelector('.Is_Connected');
                    const db = document.querySelector('.Check_Database');
                    if (!con || !db) return;

                    db.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            db.style.display = 'block';
                            timerId = null;
                        }, 4000);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(con)) db.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(con)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(con, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(con)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                (() => {
                    const el = document.querySelector('.Check_Database');
                    if (!el) return;
                    el.style.color = 'inherit';

                    const endpoints = [
                        '/api/check_database',
                        '/check_database.php',
                        '/db/ping',
                        '/api/ping'
                    ];

                    const timeoutFetch = (url, ms = 4000) => {
                        const ac = new AbortController();
                        const id = setTimeout(() => ac.abort(), ms);
                        return fetch(url, { signal: ac.signal }).finally(() => clearTimeout(id));
                    };

                    async function probeEndpoints() {
                        for (const url of endpoints) {
                            try {
                                el.textContent = `Checking ${url} ...`;
                                const res = await timeoutFetch(url, 4000);
                                if (!res) throw new Error('no response');
                                if (res.ok) {
                                    // try to read json or text for quick status message
                                    let info = '';
                                    try {
                                        const j = await res.clone().json();
                                        info = j && (j.status || j.ok || j.message) ? JSON.stringify(j) : JSON.stringify(j);
                                    } catch {
                                        info = (await res.text().catch(() => '')).slice(0, 200);
                                    }
                                    el.textContent = `Database OK (endpoint: ${url})${info ? '  ' + info : ''}`;
                                    el.style.color = 'lime';
                                    return true;
                                } else {
                                    el.textContent = `Endpoint ${url} returned ${res.status}`;
                                }
                            } catch (err) {
                                el.textContent = `${url} failed: ${err && err.name ? err.name : err}`;
                            }
                            // small pause between tries
                            await new Promise(r => setTimeout(r, 300));
                        }
                        return false;
                    }

                    async function tryWebSocketFallback() {
                        try {
                            el.textContent = 'Trying WebSocket fallback...';
                            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
                            const wsUrl = `${proto}//${location.host}/ws/db`;
                            return await new Promise((resolve) => {
                                let settled = false;
                                const ws = new WebSocket(wsUrl);
                                const to = setTimeout(() => {
                                    if (!settled) {
                                        settled = true;
                                        try { ws.close(); } catch {}
                                        resolve(false);
                                    }
                                }, 5000);
                                ws.addEventListener('open', () => {
                                    if (settled) return;
                                    settled = true;
                                    clearTimeout(to);
                                    el.textContent = `Database OK (websocket: ${wsUrl})`;
                                    el.style.color = 'lime';
                                    try { ws.close(); } catch {}
                                    resolve(true);
                                });
                                ws.addEventListener('error', () => {
                                    if (settled) return;
                                    settled = true;
                                    clearTimeout(to);
                                    try { ws.close(); } catch {}
                                    resolve(false);
                                });
                            });
                        } catch {
                            return false;
                        }
                    }

                    async function runCheck() {
                        el.textContent = 'Checking database...';
                        el.style.color = 'inherit';
                        const ok = await probeEndpoints();
                        if (ok) return;
                        const wsOk = await tryWebSocketFallback();
                        if (!wsOk) {
                            el.textContent = 'Database appears unavailable';
                            el.style.color = 'red';
                        }
                    }

                    // initial check and periodic re-check while visible
                    runCheck();
                    const intervalId = setInterval(() => {
                        if (getComputedStyle(el).display !== 'none') runCheck();
                    }, 30000);

                    // stop interval when element hidden
                    const mo = new MutationObserver(() => {
                        if (getComputedStyle(el).display === 'none') {
                            clearInterval(intervalId);
                            mo.disconnect();
                        }
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => {
                        clearInterval(intervalId);
                        mo.disconnect();
                    });
                })();

                //Continue_To_Login

                (() => {
                    const db = document.querySelector('.Check_Database');
                    const login = document.querySelector('.Continue_To_Login');
                    if (!db || !login) return;

                    login.style.display = 'none';
                    let timerId = null;

                    function isDisplayed(el) {
                        return getComputedStyle(el).display !== 'none' && el.offsetParent !== null;
                    }

                    function scheduleShow() {
                        if (timerId) return;
                        timerId = setTimeout(() => {
                            login.style.display = 'block';
                            timerId = null;
                        }, 2000);
                    }

                    function cancelShow() {
                        if (timerId) {
                            clearTimeout(timerId);
                            timerId = null;
                        }
                        if (!isDisplayed(db)) login.style.display = 'none';
                    }

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(db)) scheduleShow();
                        else cancelShow();
                    });
                    mo.observe(db, { attributes: true, attributeFilter: ['style', 'class'] });

                    if (isDisplayed(db)) scheduleShow();

                    window.addEventListener('beforeunload', () => {
                        if (timerId) clearTimeout(timerId);
                        mo.disconnect();
                    });
                })();

                (()=>{
                    const btn = document.querySelector('.Continue_To_Login');
                    const boot = document.querySelector('.Boot_Sequense');
                    if (!btn || !boot) return;
                    btn.addEventListener('click', () => {
                        // hide/close boot sequence but DO NOT exit fullscreen
                        boot.style.display = 'none';
                    });
                })();

                /* ============================================================================ */
                /* TEXT JUMP */
                /* ============================================================================ */

                // jump to Detect_Device_Information when it becomes visible

                (() => {
                    const el = document.querySelector('.Detect_Device_Information');
                    if (!el) return;

                    const isDisplayed = e => getComputedStyle(e).display !== 'none' && e.offsetParent !== null;
                    let lastJump = 0;

                    function jumpToEl() {
                        if (!isDisplayed(el)) return;
                        const now = Date.now();
                        if (now - lastJump < 800) return; // debounce repeated jumps
                        lastJump = now;
                        // allow layout to settle
                        setTimeout(() => {
                            try {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                                if (typeof el.focus === 'function') el.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }, 60);
                    }

                    // initial check
                    if (isDisplayed(el)) jumpToEl();

                    // observe visibility changes
                    const mo = new MutationObserver(() => {
                        if (isDisplayed(el)) jumpToEl();
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                // jump to Get_Network_Information when it becomes visible
                
                (() => {
                    const el = document.querySelector('.Get_Network_Information');
                    if (!el) return;
                    const isDisplayed = e => getComputedStyle(e).display !== 'none' && e.offsetParent !== null;
                    let lastJump = 0;

                    function jumpToEl() {
                        if (!isDisplayed(el)) return;
                        const now = Date.now();
                        if (now - lastJump < 800) return;
                        lastJump = now;
                        setTimeout(() => {
                            try {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                                if (typeof el.focus === 'function') el.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }, 60);
                    }

                    if (isDisplayed(el)) jumpToEl();

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(el)) jumpToEl();
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                // jump to Is_Connected when it becomes visible

                (() => {
                    const el = document.querySelector('.Is_Connected');
                    if (!el) return;
                    const isDisplayed = e => getComputedStyle(e).display !== 'none' && e.offsetParent !== null;
                    let lastJump = 0;

                    function jumpToEl() {
                        if (!isDisplayed(el)) return;
                        const now = Date.now();
                        if (now - lastJump < 800) return;
                        lastJump = now;
                        setTimeout(() => {
                            try {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                                if (typeof el.focus === 'function') el.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }, 60);
                    }

                    if (isDisplayed(el)) jumpToEl();

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(el)) jumpToEl();
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                // jump to Check_Database when it becomes visible

                (() => {
                    const el = document.querySelector('.Check_Database');
                    if (!el) return;
                    const isDisplayed = e => getComputedStyle(e).display !== 'none' && e.offsetParent !== null;
                    let lastJump = 0;

                    function jumpToEl() {
                        if (!isDisplayed(el)) return;
                        const now = Date.now();
                        if (now - lastJump < 800) return;
                        lastJump = now;
                        setTimeout(() => {
                            try {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                                if (typeof el.focus === 'function') el.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }, 60);
                    }

                    if (isDisplayed(el)) jumpToEl();

                    const mo = new MutationObserver(() => {
                        if (isDisplayed(el)) jumpToEl();
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });

                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                // jump to Continue_To_Login when it becomes visible

                (() => {
                    const el = document.querySelector('.Continue_To_Login');
                    if (!el) return;
                    const isDisplayed = e => getComputedStyle(e).display !== 'none' && e.offsetParent !== null;
                    let lastJump = 0;
                    function jumpToEl() {
                        if (!isDisplayed(el)) return;
                        const now = Date.now();
                        if (now - lastJump < 800) return;
                        lastJump = now;
                        setTimeout(() => {
                            try {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                                if (typeof el.focus === 'function') el.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }, 60);
                    }
                    if (isDisplayed(el)) jumpToEl();
                    const mo = new MutationObserver(() => {
                        if (isDisplayed(el)) jumpToEl();
                    });
                    mo.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });
                    window.addEventListener('beforeunload', () => mo.disconnect());
                })();

                
                /* Replace smooth, eased scrolling with intentionally choppy stepped scrolling.
                   - cancels on user interaction
                */
                (function(){
                    const nativeElScroll = Element.prototype.scrollIntoView;
                    const nativeWinScroll = window.scrollTo;
                    let intervalId = null;

                    function cancel() { if (intervalId) { clearInterval(intervalId); intervalId = null; } }
                    ['wheel','touchstart','pointerdown','keydown'].forEach(e =>
                        window.addEventListener(e, cancel, { passive: true, capture: true })
                    );

                    function computeTargetY(el, block){
                        const rect = el.getBoundingClientRect();
                        const scrollTop = window.scrollY || window.pageYOffset || 0;
                        const elTop = rect.top + scrollTop;
                        const elBottom = rect.bottom + scrollTop;
                        switch(block){
                            case 'center': return Math.round(elTop - (window.innerHeight - rect.height) / 2);
                            case 'end':    return Math.round(elBottom - window.innerHeight);
                            case 'nearest':
                                if (elTop < scrollTop) return elTop;
                                if (elBottom > scrollTop + window.innerHeight) return elBottom - window.innerHeight;
                                return scrollTop;
                            case 'start':
                            default: return Math.round(elTop);
                        }
                    }

                    function choppyScrollTo(targetY){
                        cancel();
                        const maxY = Math.max(0, document.documentElement.scrollHeight - window.innerHeight);
                        const dest = Math.max(0, Math.min(targetY, maxY));
                        const start = window.scrollY || window.pageYOffset || 0;
                        if (Math.abs(dest - start) < 1) return;
                        const direction = dest > start ? 1 : -1;
                        const STEP_PX = 120;   // large jump per tick -> "choppy"
                        const TICK_MS  = 80;   // tick interval
                        intervalId = setInterval(() => {
                            const cur = window.scrollY || window.pageYOffset || 0;
                            const next = cur + direction * STEP_PX;
                            if ((direction > 0 && next >= dest) || (direction < 0 && next <= dest)) {
                                window.scrollTo(0, dest);
                                cancel();
                            } else {
                                window.scrollTo(0, Math.round(next));
                            }
                        }, TICK_MS);
                    }

                    Element.prototype.scrollIntoView = function(arg){
                        try {
                            let behavior = 'auto', block = 'start';
                            if (arg == null) {}
                            else if (typeof arg === 'object') { behavior = arg.behavior || 'auto'; block = arg.block || 'start'; }
                            else if (typeof arg === 'boolean') { block = arg ? 'start' : 'end'; }
                            else if (typeof arg === 'string') { behavior = arg; }

                            if (behavior === 'smooth') {
                                const targetY = computeTargetY(this, block);
                                choppyScrollTo(targetY);
                                return;
                            }
                            return nativeElScroll.call(this, arg);
                        } catch (e) {
                            return nativeElScroll.call(this, arg);
                        }
                    };

                    window.scrollTo = function(...args){
                        if (args.length === 1 && typeof args[0] === 'object' && args[0].behavior === 'smooth') {
                            const top = args[0].top != null ? args[0].top : (window.scrollY || 0);
                            choppyScrollTo(top);
                            return;
                        }
                        return nativeWinScroll.apply(window, args);
                    };
                })();

                /* ============================================================================ */
                /* RUN BOOT SEQUENSE PROGRESS BAR */
                /* ============================================================================ */

                (() => {
                    const fill = document.querySelector('.Boot_Sequense_Progress_Bar_Fill');
                    const boot = document.querySelector('.Boot_Sequense');
                    const progressBar = document.querySelector('.Boot_Sequense_Progress_Bar');
                    if (!fill || !boot || !progressBar) return;

                    // ensure progress bar is pinned to bottom:10px regardless of layout
                    function pinProgressBar() {
                        progressBar.style.position = 'fixed';
                        progressBar.style.left = '10px';
                        progressBar.style.right = '10px';
                        progressBar.style.bottom = '10px';
                        progressBar.style.width = 'calc(100% - 20px)';
                        progressBar.style.zIndex = '9999';
                    }
                    pinProgressBar();
                    window.addEventListener('resize', pinProgressBar);
                    // also ensure it's pinned whenever boot visibility toggles (handled later)

                    // Steps mapped to approximate progress percentages
                    const steps = [
                        { sel: '.Boot_Sequense_Start_String', pct: 6 },
                        { sel: '.Boot_Sequense_MIT_License',    pct: 28 },
                        { sel: '.Site_Language',               pct: 40 },
                        { sel: '.Main_IDE_Editor',             pct: 48 },
                        { sel: '.Seperator_1',                 pct: 52 },
                        { sel: '.Detect_Device_Information',   pct: 68 },
                        { sel: '.Get_Network_Information',     pct: 76 },
                        { sel: '.Is_Connected',                pct: 86 },
                        { sel: '.Check_Database',              pct: 96 },
                        { sel: '.Continue_To_Login',           pct: 100 }
                    ];

                    // helper
                    const isDisplayed = el => el && getComputedStyle(el).display !== 'none' && el.offsetParent !== null;

                    // initial reset
                    fill.style.transition = 'none';
                    fill.style.width = '0%';
                    fill.setAttribute('role','progressbar');
                    fill.setAttribute('aria-valuemin','0');
                    fill.setAttribute('aria-valuemax','100');

                    // track which steps we've already advanced for
                    const done = new Set();

                    // choppy stepping state
                    let choppyInterval = null;

                    function getCurrentPct() {
                        const w = (fill.style.width || '').trim();
                        return w.endsWith('%') ? parseFloat(w) || 0 : 0;
                    }

                    function stopChoppy() {
                        if (choppyInterval) {
                            clearInterval(choppyInterval);
                            choppyInterval = null;
                        }
                        // ensure no CSS transition smoothness
                        fill.style.transition = 'none';
                    }

                    // updateFill uses stepped jumps (choppy) instead of smooth tween
                    function updateFill(targetPct) {
                        stopChoppy();
                        const start = getCurrentPct();
                        const dest = Math.max(0, Math.min(100, targetPct));
                        if (Math.abs(dest - start) < 0.5) {
                            fill.style.width = dest + '%';
                            fill.setAttribute('aria-valuenow', String(Math.round(dest)));
                            return;
                        }

                        // determine step size (larger jumps => choppier)
                        const diff = Math.abs(dest - start);
                        const STEP_PCT = Math.max(6, Math.round(diff / 3)); // coarse steps
                        const TICK_MS = 120; // interval between jumps (choppy feel)
                        const dir = dest > start ? 1 : -1;
                        let cur = start;

                        // perform immediate first jump to avoid long pauses
                        cur = Math.round((cur + dir * STEP_PCT) * 100) / 100;
                        if ((dir > 0 && cur > dest) || (dir < 0 && cur < dest)) cur = dest;
                        fill.style.width = cur + '%';
                        fill.setAttribute('aria-valuenow', String(Math.round(cur)));

                        choppyInterval = setInterval(() => {
                            cur = Math.round((cur + dir * STEP_PCT) * 100) / 100;
                            if ((dir > 0 && cur >= dest) || (dir < 0 && cur <= dest)) {
                                fill.style.width = dest + '%';
                                fill.setAttribute('aria-valuenow', String(Math.round(dest)));
                                stopChoppy();
                                return;
                            }
                            fill.style.width = cur + '%';
                            fill.setAttribute('aria-valuenow', String(Math.round(cur)));
                        }, TICK_MS);
                    }

                    // scan and advance to highest matching step
                    function scanAndAdvance() {
                        for (let i = 0; i < steps.length; i++) {
                            const s = steps[i];
                            const el = document.querySelector(s.sel);
                            if (el && isDisplayed(el) && !done.has(s.sel)) {
                                done.add(s.sel);
                                updateFill(s.pct);
                            }
                        }
                    }

                    // observe visibility/style/class changes globally while boot is visible
                    const mo = new MutationObserver(() => {
                        if (getComputedStyle(boot).display === 'none') return;
                        pinProgressBar();
                        scanAndAdvance();
                    });
                    mo.observe(document.body, { attributes: true, subtree: true, attributeFilter: ['style', 'class'] });

                    // also poll periodically to catch programmatic changes that don't trigger attribute mutations
                    const pollId = setInterval(() => {
                        if (getComputedStyle(boot).display === 'none') return;
                        pinProgressBar();
                        scanAndAdvance();
                    }, 700);

                    // reset when boot sequence hides so the bar can be reused later
                    const bootMo = new MutationObserver(() => {
                        if (getComputedStyle(boot).display === 'none') {
                            done.clear();
                            stopChoppy();
                            fill.style.width = '0%';
                            fill.setAttribute('aria-valuenow','0');
                        } else {
                            // when shown, ensure at least initial step is scanned and bar pinned
                            pinProgressBar();
                            setTimeout(scanAndAdvance, 80);
                        }
                    });
                    bootMo.observe(boot, { attributes: true, attributeFilter: ['style', 'class'] });

                    // initial scan in case some items are already visible
                    setTimeout(scanAndAdvance, 60);

                    window.addEventListener('beforeunload', () => {
                        mo.disconnect();
                        bootMo.disconnect();
                        clearInterval(pollId);
                        stopChoppy();
                    });
                })();

                /* ============================================================================ */
                /* LOAD SPLASH SCREEN */
                /* ============================================================================ */

                (() => {
                    const fill = document.querySelector('.Boot_Sequense_Progress_Bar_Fill');
                    const boot = document.querySelector('.Boot_Sequense');
                    const splash = document.querySelector('.Slpash_Screen'); // note: element name in document

                    if (!fill || !boot || !splash) return;

                    let fired = false;

                    function getPct() {
                        const aria = fill.getAttribute('aria-valuenow');
                        if (aria != null) {
                            const n = parseFloat(aria);
                            if (!Number.isNaN(n)) return n;
                        }
                        const w = (fill.style.width || getComputedStyle(fill).width || '').toString().trim();
                        if (w.endsWith('%')) return parseFloat(w);
                        return null;
                    }

                    function onFull() {
                        if (fired) return;
                        fired = true;
                        // small delay to allow final visuals to settle
                        setTimeout(() => {
                            try {
                                boot.style.display = 'none';
                                splash.style.display = 'flex';
                                // remove dot grid if present
                                document.querySelectorAll('.Dot_Grid').forEach(e => e.remove());
                            } catch (e) { /* ignore */ }
                        }, 150);
                    }

                    // observe style/aria changes on the fill element
                    const mo = new MutationObserver(() => {
                        const pct = getPct();
                        if (pct != null && pct >= 100) onFull();
                    });
                    mo.observe(fill, { attributes: true, attributeFilter: ['style', 'aria-valuenow'] });

                    // fallback poll to catch other updates
                    const poll = setInterval(() => {
                        const pct = getPct();
                        if (pct != null && pct >= 100) {
                            clearInterval(poll);
                            mo.disconnect();
                            onFull();
                        }
                        if (fired) {
                            clearInterval(poll);
                            mo.disconnect();
                        }
                    }, 200);

                    window.addEventListener('beforeunload', () => {
                        clearInterval(poll);
                        mo.disconnect();
                    });
                })();

            </script>
        </div>
    </div>

    <div class="Slpash_Screen" style="display: none;">
        <style aria-label="Start_Body_Style">
            .St {
                background-color: var(--Background);
                width: 100dvw;
                height: 100dvh;
                display: flex;
                justify-content: center;
                align-items: center;
            }

        </style>
        <div class="Logo">
            <p class="Logo_Text">Welcome to Eden Economy</p>

            <style aria-label="Logo_Style">
                .Logo {
                    font-size: var(--Main_Text_4);
                    font-weight: bold;
                    color: var(--Highlight_Color_1);
                    text-shadow: 0 0 8px var(--Highlight_Color_1);
                }
            </style>
        </div>
    </div>

    <div class="Login" style="display: none;">
        <div class="Login_Wallpaper">
            <img class="Login_Wallpaper_Image" src="Images/Wallpaper/Wallpaper_1.jpg" alt="Wallpaper 1">
            <div class="Login_Glass">

            </div>
        </div>

        <style aria-label="Login_Style">
            .Login {
                position: absolute;
                top: 0;
                left: 0;
                width: 100dvw;
                height: 100dvh;
                display: flex;
            }

            .Login_Wallpaper {
                width: 100dvw;
                height: 100dvh;
            }

            .Login_Wallpaper_Image {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .Login_Glass {
                position: absolute;
                top: 0;
                left: 0;
                width: 100dvw;
                height: 100dvh;
                backdrop-filter: blur(10px);
            }
        </style>
    </div>

    <div class="EEC_Main_1">

    </div>

    <div class="EEC_Main_2">

    </div>

    <div class="EEC_Main_3">

    </div>
    
    <script aria-label="Essentials_Script">

        /* ============================================================================ */
        /* DRAGGING ALL WINDOWS AND PANELS */
        /* ============================================================================ */

        // Enable dragging of any element with class "Window" by its child ".Window_Header"

        (() => {
            const headers = document.querySelectorAll('.Window_Header');
            headers.forEach(header => {
                // visual affordance
                header.style.cursor = 'grab';
                header.style.touchAction = 'none'; // allow pointer events without scrolling

                header.addEventListener('pointerdown', (ev) => {
                    const win = header.closest('.Window');
                    if (!win) return;

                    // ensure the window can be moved by absolute positioning
                    const rect = win.getBoundingClientRect();
                    const docLeft = rect.left + window.scrollX;
                    const docTop = rect.top + window.scrollY;
                    const computed = getComputedStyle(win);
                    if (computed.position === 'static') {
                        win.style.position = 'absolute';
                        win.style.left = `${docLeft}px`;
                        win.style.top = `${docTop}px`;
                    } else {
                        // make sure left/top are numbers we can use
                        if (!win.style.left) win.style.left = `${docLeft}px`;
                        if (!win.style.top) win.style.top = `${docTop}px`;
                    }

                    header.setPointerCapture(ev.pointerId);
                    header.style.cursor = 'grabbing';

                    const startX = ev.clientX;
                    const startY = ev.clientY;
                    const startLeft = parseFloat(win.style.left || docLeft);
                    const startTop = parseFloat(win.style.top || docTop);

                    function onPointerMove(e) {
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        win.style.left = `${Math.round(startLeft + dx)}px`;
                        win.style.top = `${Math.round(startTop + dy)}px`;
                    }

                    function onPointerUp(e) {
                        header.releasePointerCapture(e.pointerId);
                        header.style.cursor = 'grab';
                        document.removeEventListener('pointermove', onPointerMove);
                        document.removeEventListener('pointerup', onPointerUp);
                    }

                    document.addEventListener('pointermove', onPointerMove);
                    document.addEventListener('pointerup', onPointerUp);
                });
            });
        })();

        (() => {
            const GRID_X = 10;
            const GRID_Y = 10;

            function snapElementToGrid(el, gx = GRID_X, gy = GRID_Y) {
                if (!el) return;
                const rect = el.getBoundingClientRect();
                const docLeft = rect.left + window.scrollX;
                const docTop = rect.top + window.scrollY;

                let left = parseFloat(el.style.left);
                let top = parseFloat(el.style.top);
                if (!Number.isFinite(left)) left = docLeft;
                if (!Number.isFinite(top)) top = docTop;

                const snappedLeft = Math.round(left / gx) * gx;
                const snappedTop = Math.round(top / gy) * gy;

                el.style.left = snappedLeft + 'px';
                el.style.top = snappedTop + 'px';
            }

            // Track which window is being dragged
            let draggingWindow = null;
            document.querySelectorAll('.Window_Header').forEach(header => {
                header.addEventListener('pointerdown', () => {
                    draggingWindow = header.closest('.Window');
                });
            });

            // Snap when pointer is released  snap the dragged window and ensure all windows align
            document.addEventListener('pointerup', () => {
                if (draggingWindow) {
                    snapElementToGrid(draggingWindow);
                    draggingWindow = null;
                }
                document.querySelectorAll('.Window').forEach(w => snapElementToGrid(w));
            });

            // Optional: live snapping while dragging (throttled with requestAnimationFrame)
            let rafId = null;
            document.addEventListener('pointermove', () => {
                if (!draggingWindow) return;
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    snapElementToGrid(draggingWindow);
                    rafId = null;
                });
            });
        })();

        (() => {
            // Clamp windows so they remain fully visible inside the viewport
            function clampWindowToViewport(win) {
                if (!win) return;
                const rect = win.getBoundingClientRect();
                const docLeft = rect.left + window.scrollX;
                const docTop = rect.top + window.scrollY;
                const width = rect.width;
                const height = rect.height;

                const vw = document.documentElement.clientWidth;
                const vh = document.documentElement.clientHeight;

                // document-scoped min/max (account for page scroll)
                const minLeft = window.scrollX;
                const minTop = window.scrollY;
                const maxLeft = Math.max(minLeft, window.scrollX + vw - width);
                const maxTop = Math.max(minTop, window.scrollY + vh - height);

                let left = parseFloat(win.style.left);
                let top = parseFloat(win.style.top);
                if (!Number.isFinite(left)) left = docLeft;
                if (!Number.isFinite(top)) top = docTop;

                const clampedLeft = Math.min(Math.max(left, minLeft), maxLeft);
                const clampedTop = Math.min(Math.max(top, minTop), maxTop);

                if (clampedLeft !== left) win.style.left = Math.round(clampedLeft) + 'px';
                if (clampedTop !== top) win.style.top = Math.round(clampedTop) + 'px';
            }

            // Throttle with rAF for smoothness
            let raf = null;
            function clampAllWindows() {
                if (raf) return;
                raf = requestAnimationFrame(() => {
                    document.querySelectorAll('.Window').forEach(clampWindowToViewport);
                    raf = null;
                });
            }

            // Keep windows inside viewport while dragging and when releasing/resizing/loading
            document.addEventListener('pointermove', clampAllWindows, { passive: true });
            document.addEventListener('pointerup', clampAllWindows);
            window.addEventListener('resize', clampAllWindows);
            window.addEventListener('load', clampAllWindows);
        })();

        /* ============================================================================ */
        /* BRING ACTIVE WINDOW TO FRONT */
        /* ============================================================================ */

        (() => {
            let topZ = 10;
            // initialize topZ from existing windows
            document.querySelectorAll('.Window').forEach(w => {
                const z = parseInt(getComputedStyle(w).zIndex, 10);
                if (Number.isFinite(z) && z >= topZ) topZ = z + 1;
                // make windows focusable so keyboard focus can also bring to front
                if (!w.hasAttribute('tabindex')) w.setAttribute('tabindex', '0');
                // bring to front when header or window gets pointerdown
                w.addEventListener('pointerdown', () => bringToFront(w));
                const hdr = w.querySelector('.Window_Header');
                if (hdr) hdr.addEventListener('pointerdown', (e) => { e.stopPropagation(); bringToFront(w); });
                // bring to front on focus (keyboard)
                w.addEventListener('focus', () => bringToFront(w));
            });

            function bringToFront(win) {
                if (!win) return;
                topZ += 1;
                win.style.zIndex = String(topZ);
                // optional active class for styling
                document.querySelectorAll('.Window').forEach(w => w.classList.toggle('active', w === win));
            }

            // expose for debugging if needed
            window.__bringWindowToFront = bringToFront;
        })();
    </script>
</body>
</html>


